# :blossom: 高效Java——基础篇

> 明白事理的人使自己适应世界；不明事理的人想让世界适应自己。——萧伯纳

## 1. 莫让常量蜕变成变量

避免常量指向一个可变的值，如：

```java
public static int RAND_CONST = new Random().nextInt()
```

> 务必让常量的值在运行期保持不变。

## 2. 三元操作符的类型务必一致

三元操作符存在隐式转换，如下：

```java
int i = 80；
String s1 = String.valueOf(i < 100? 90 : 100.0)；
```

结果：s1 = 90.0。

因为三元操作符的类型不一致，导致整型向浮点型进行了转换。三元操作符类型转换的规则，如下：

- 若两个操作数不可转换，则不做转换，返回值为Object类型
- 若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等
- 若两个操作数中有一个是数字S，另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型
- 若两个操作数都是直接量数字，则返回值类型为范围较大者

## 3. 避免带有变长参数的方法重载

避免使用变长参数的方法重载，如果出现冲突的方法，那么就会使用最简单的那个方法。

```java
//method 1
public void method(int a, int b);

//method 2
public void method(int a, int... b);
```

当我们调用method(1, 2), 那么最终调用到的是method1。

> 此外，还有以下建议:
>
> - 别让null值和空值威胁到变长方法

## 4. 覆写变长方法也循规蹈矩

覆写函数必须遵循以下条件：

- 重写方法不能缩小访问权限
- 参数列表必须与被重写方法相同
- 返回类型必须与被重写方法的相同或是其子类
- 重写方法不能抛出新的异常，或者超出父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常

> 覆写的方法参数与父类相同，不仅仅是类型、数量，还包括显示形式。

## 5. 警惕自增的陷阱

```java
int i = 0;
for(;i < 10; i++) {
    i=i++
}
System.out.println("i" + i);
```

i的结果是?

## 6. 养成良好习惯，显式声明UID

类实现Serializable接口的目的是为了可持久化，比如网络传输或本地存储，为系统的分布和异构部署提供先决支持条件。

通过SerialVersionUID来给类声明一个版本号，SerialVersionUID也叫做流标识符（Stream Unique Identifier），即类的版本定义的，它可以显式声明也可以隐式声明。

隐式声明：隐式声明则是我不声明，你编译器在编译的时候帮我生成。生成的依据是通过包名、类名、继承关系、非私有的方法和属性，以及参数、返回值等诸多因子计算得出的，极度复杂，基本上计算出来的这个值是唯一的。

> 显式声明serialVersionUID可以避免对象不一致，但尽量不要以这种方式向JVM“撒谎”。

## 7. 避免用序列化类在构造函数中为不变量赋值

保持新旧对象的final变量相同，有利于代码业务逻辑统一，这是序列化的基本规则之一，也就是说，如果final属性是一个直接量，在反序列化时就会重新计算。

执行反序列化时，不会执行构造函数。

> 反序列化时final变量在以下情况下不会被重新赋值：
>
> - 通过构造函数为final变量赋值
> - 通过方法返回值为final变量赋值
> - final修饰的属性不是基本类型

## 8. 使用序列化类的私有方法巧妙解决部分属性持久化问题

可以实现了Serializable接口的类可以实现两个私有方法：writeObject和readObject，以影响和控制序列化和反序列化的过程。

使用了序列化独有的机制：序列化回调。

Java调用ObjectOutputStream类把一个对象转换成流数据时，会通过反射（Reflection）检查被序列化的类是否有writeObject方法，并且检查其是否符合私有、无返回值的特性。若有，则会委托该方法进行对象序列化，若没有，则由ObjectOutputStream按照默认规则继续序列化。同样，在从流数据恢复成实例对象时，也会检查是否有一个私有的readObject方法，如果有，则会通过该方法读取属性值。

> [!attention]
> 总结来说，序列化应该谨慎使用，原因如下：
>
> - 一旦类被发布，则会大大降低了“改变这个类的实现”灵活性
> - 增加了Bug和安全漏洞的可能性（**安全漏洞可以扩展学习**）
> - 随着类发行新的版本，相关的测试负担也会增加
> - 为了继承而设计的类应该尽可能少地去实现Serializable这个接口，用户的接口也应该尽可能少继承Serializable接口
> - 内部类不应该实现Serializable接口

## 9. 用整数类型处理货币

使用浮点型来处理货币，会因为浮点型的存储方式（计算机存储浮点原理）导致数据不准备，因此处理货币时，应使用整数类型来避免这个问题。

> 使用BigDecimal也是一个不错的选择。

## 10. 不要让类型默默地转换

使用基本类型时，应注意基本类型的取值范围，以及其默认的强制转换处理。

## 11. 不要随便设置随机种子

在Java中，随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：

- 种子不同，产生不同的随机数
- 种子相同，即使实例不同也产生相同的随机数

> 若非必要，不要设置随机数种子。

## 12. 将局部变量的作用域最小化

将局部变量的作用最小化，最有力的方法就是在第一次使用它的地方声明。

几乎每个局部变量的声明都应该包含一个初始表达式，也就是保持单一引用点。如果你还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟声明这个变量，直到初始化为止。

> for、foreach循环提供了一个机会来将变量的作用域最小化，因此它们都优于while循环。

## 13. for-each循环优先于传统的for循环

for-each循环在简洁性和预防bug方面有着传统的for循环无法比拟的优势，并且没有性能损失。应该尽可能地使用for-each循环、

遗憾的是，有以下三种情况无法使用for-each循环：

- 过滤
- 转换
- 平行迭代

虽然以上不能使用for-each循环，但是可以使用stream或for循环来替代。

> 实现Iterator接口的自定义类，也可以使用for-each来遍历。

## 14. 如果其他类型更适合，则尽量避免使用字符串

如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。若使用不当，字符串会比其他的类型更加笨拙、更不灵活、速度更慢、也更容易出错。

字符串经常被错误地用来代替的类型，包括基本类型、枚举类型和聚合类型。

## 15. 考虑使用自定义的序列化形式

如果类实现了Serializable接口，并且使用了默认的序列化形式，那么对类中已经存在的实现进行删除或者变更，那么在没有显示声明UID的情况下，就会导致出现异常。

如果一个对象的物理表示法等同于它的逻辑内容，可能就适用于使用默认的序列化形式（但尽量还是要显示声明UID）。

当一个对象的物理表示法与它的逻辑数据内容有实质性的差别时，应该自定义序列化形式，如Jdk的集合类，都自定义了序列化。

在自定义序列化的时候，可以自定义writeObject以及readObject方法，实现自定义序列化的处理。但是如果在读取整个对象状态的任何其他方法上限制任何同步，则也必须在对象序列化上强制同步，否则就有遭遇资源排列死锁的风险。


