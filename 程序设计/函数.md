# :clap: 函数

> 简单是可靠性的先决条件。-- Edsger Dijkstra

## 短小

如果度量短小？一般20行封顶最佳。

对于代码块（if、else、while等），其中的代码块应该只有一行，该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较高说明性的名称，从而增加了文档上的价值。

函数的缩进层级不该多于一层或两层。

> [!tip]
> 短小的函数，易于阅读和理解。

> 这一点在[长函数](https://lvanliu.github.io/LvanNote/#/程序设计/代码的坏味道?id=_7-长函数)也有提及。

## 只做一件事

函数应该做一件事。做好这件事。只做一件事。

如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事。编写函数毕竟是为了把大一些的概念（换言之，函数的名称）拆分为另一抽象层上的一系列步骤。

判断函数是否只做了一件事，就是看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现。

> [!tip]
> 只做一件事，也就是单一职责原则。

## 每个函数一个抽象层级

函数中混杂不同抽象层级，往往让人很迷惑。读者可能无法判断某个表达式是基础概念还是细节。更恶劣的是，就像破损的窗户，一旦细节与基础概念混杂，更多的细节就会在函数中纠结起来。

### 自顶向下读代码：向下规则

我们想要让代码拥有向下的阅读顺序。我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能遵循抽象层级向下阅读了，这就是向下规则。

## switch语句

使用switch语句会违背以下原则：

- 单一职责原则
- 开闭原则

可以使用多态来优化switch语句。

> 这一点在[滥用控制语句](https://lvanliu.github.io/LvanNote/#/程序设计/代码的坏味道?id=_2-滥用控制语句)也被提及。

## 使用描述性的名称

> 如果每个例程都让你感到深合己意，那就是整洁的代码 ——沃德原则

好的函数名称应该描述了函数做的事。函数越短小、功能越集中、就越便于取个好名字。

别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。

命名方式要保持一致，使用与模块名一脉相承的短语、名称或动词给函数命名。

## 一元函数的普遍形式

- 询问关于参数的问题，如：boolean fileExists("MyFile")。
- 操作该参数，进行转换处理，如：InputStream fileOpen("MyFile")
- 事件处理，小心使用这种方式，应该让读者很清楚地了解它是个事件。谨慎地使用名称和上下文语境。如：void passwordAttemptFailedNtimes(int attempts) 。

> [!tip]
> 尽量避免编写不遵循这些形式的一元参数

## 标识参数

标识参数丑陋不堪，使用了标识参数，函数就不止做一件事，违反了函数的单一原则。

## 二元函数

二元函数比一元函数难懂，二元函数不算恶劣，而且你当然也会编写二元函数。不过，使用二元函数要付出代价。你应该尽量利用一些机制将其转换成一元函数。

> 这一点，也在[长参数列表](https://lvanliu.github.io/LvanNote/#/程序设计/代码的坏味道?id=_8-长参数列表)中提及。

## 三元函数

三元函数要比二元函数难懂得多。排序、琢磨、忽略得问题都会加倍体现。建议你在写三元函数前一定要想清楚。

## 参数对象

如果函数看来需要两个、三个或者三个以上参数，就应该将这些参数封装成类。

从参数创建对象，从而减少参数数量，看起来像是在作弊，但实则并非如此。当一组参数被共同传递，往往就该有自己名称得某个概念的一部分。

> 这一点，也在[长参数列表](https://lvanliu.github.io/LvanNote/#/程序设计/代码的坏味道?id=_8-长参数列表)中提及。

## 参数列表

没什么说的，可变的参数列表不要写。

## 动词与关键字

给函数取个好名字，能较好地解释函数的意图，以及参数的顺序和意图。

## 无副作用

副作用是一种谎言，函数承诺只做一件事，但还是会做其他被藏起来的事，它具有破坏性，会导致古怪的时序性耦合及顺序依赖。

## 输出参数

应避免使用输出参数，如果函数必须要修改某种状态，就修改所属对象的状态。

## 分隔指令与询问

函数要么做什么事，要么回答什么事，但二者不可兼得。函数应该修改某对象的状态或者返回该对象的有关信息，两样都干常会导致混乱。

可以把指令与询问分隔开，防止混淆的发生。

## 使用异常替代返回错误码

从指令返回错误码轻微违反了指令与询问分隔的原则，它鼓励了在if语句判断中把指令当作表达式使用。这并不会引起动词/形容词混淆，但却导致更深层次的嵌套结构。当返回错误码时，就是在要求调用者立刻处理错误。

另一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化。

## 抽离try/catch代码块

try/catch代码块丑陋不堪。它们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把try/catch代码块的主体部分抽离出来，另外形成函数。

## 错误处理就是一件事

函数通常应该只做一件事。错误处理就是一件事，因此处理错误的函数不该做其他事。这意味着，如果try在某个函数中存在，它就该是这个函数的第一个单词，而且在catch/finally代码块后面也不该有其他内容。

## Error.java依赖磁铁

返回错误码通常暗示某处有个类或者枚举，定义了所有的错误码，这样的类就是一块依赖磁铁。其他许多类都得导入和使用它，当Error枚举被修改时，所有这些其他的类都需要重新编译和部署。这对Error类造成了负面压力。

使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。

## 结构化编程

Edsger Dijkstra的结构化编程规则：每个函数，函数中的每个代码块都应该有一个入口、一个出口。遵循这些原则，意味着每个函数中只该有一个return语句，循环中不能有break和continue语句，而且永远不能有goto语句。

但对于小函数而言，这些规则助益不大。只有在大函数中，这些规则才会有明显的好处。

## 总结

写函数时，一开始都冗长而复杂，不符合规范，但需要配上一套单元测试，覆盖每行丑陋的代码。

随后，打磨这些代码，参考以上规则进行优化，并使用编写好的单元测试进行验证。

没人能做到，从一开始就按照规则写函数。
