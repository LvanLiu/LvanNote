# 软件设计技巧

> :pencil2: 光有知识是不够的，还应当运用；光有愿望是不够的，还应当行动。——歌德

## 抽象

?> 概念

抽象，是指在概念上明确划清界限。这种明确划清界限的方式可以将一个模块与其他模块区分开来。

抽象由“舍象”和“一般化”这两个观点组合而成。

舍象指的是舍去复杂对象的几个性质，只关注其特定的性质。一般化指的是从具体对象中抽出共同的性质，将其固定为更加通用的概念。

?> 实践

在处理复杂事物时要进行舍象。舍弃多余的东西，抓住本质。需要注意的是，事物的本质固然重要，但在处理问题时，我们更应该关注当前问题的本质。

在处理多个不同的事物时要采用一般化的手段。抽取对象共同的性质，将这些共同点组合成通用的概念。

## 封装

?> 概念

将相互关联的数据和逻辑分到一组，定义为一个模块。用模块这层外衣将关联性较强的数据群和逻辑群包裹起来的做法称为封装。

各个模块会作为完全不相关的东西分开进行处理。

?> 实践

将相互关联的数据和逻辑分到一组，整理成一个模块。

封装时仅添加相关元素，决不能让无关的元素混入模块中。有了关联性很强的数据组成的数据结构，以及关联性很强的逻辑组成的函数群之后，我们便能获得简洁且高质量的模块了。

## 信息隐藏

?> 概念

对使用模块的用户隐藏模块实现相关的信息。

模块内有哪些数据，函数是用何种逻辑实现功能的，这些信息全部对外隐藏。我们要让外部无法直接访问模块内的数据。模块的函数也尽量不公开。

用户只能通过最低限度公开的函数来操作模块。

?> 实践

仅公开模块简单的功能，内部状态和内部功能全部隐藏。禁止外部访问模块内部的数据以及仅供模块内部使用的函数。

实现信息隐藏需要使用封装的手段。分组可以整理“关系网”，降低隐藏信息的难度。

!> 信息隐藏，可以减少接口的代码量，让信息交互变得简洁，降低代码的复杂程度，同时利于排除多余信息的干扰，便于用户使用。

> [!tip|label:关联的原则]
>
>
> Parnas原则
>
> - 对于模块的使用者，仅提供使用该模块所必需的所有信息，其余信息一概不予提供
> - 对于模块的开发者，仅提供实现该模块所必需的所有信息，其余信息一概不予提供

## 打包

?> 概念

将模块按照某种有意义的单位整理并分组，其实就是将整个软件按照某种有意义的单位进行分割。这种分割后的产物称为“包”。

包决定了以何种方法将软件的理论结构存储为物理结构。包起到的是物理容器的作用，主要用来以某种有意义的单位存放软件的功能。

?> 实践

将相互关联的模块集中起来打包。

我们要等模块积攒到一定数量之后再自下而上地对包进行设计。这项工作不可能一开始就通过自上而下的方式来完成。

包这种比较大的分解单位容易被误认为是用于功能分解的单位，但包其实是表现软件构建方法的“图纸”。项目最初并没有可以构建的软件，所以不可能实现自上而下的设计。

随着开发的进行，模块将越来越多。此时我们就可以开始自下而上地设计包了。包的设计并不是一锤子买卖，包还要随着编程的推进不断成长和进化。

> [!tip|label:优点]
>
> - 整个软件被分割成包，复杂度下降
> - 包内没有不相关的模块，便于管理
> - 基本可以把修改带来的影响限制在包内，代码的修改因此变得更加方便
> - 依赖关系得到整理，方便代码以包为单位重复使用

## 关注点分离

?> 概念

关注点指软件的功能或目的。把关注点“分离”，就是将与各个关注点有关的代码集中起来做成独立的模块，与其他代码分离。分离后的模块要尽量减少公开的功能数量，与其他模块的关联也要维持在最低限度。

MVC以及AOP是关注点分离的最佳实践。

?> 实践

以关注点为单位创建模块，把不同的功能、不相关的功能分开。

另外，如果一个模块在不同前提下有不同的功能，我们就需要分割该模块，让各个功能处于独立的状态。一般来讲，一个模块不可以拥有多个功能。

实现关注点分离的好处

- 各个关注点互相独立，从而缩小了代码的修改范围，使代码更易于修改
- 各个关注点互相独立，从而缩小了代码的修改范围，使代码更易于修改
- 因为代码的编写是以关注点为单位进行的，所以能够实现并行开发

> [!tip|label:关联的原则]
>
> 关联：面向切面编程

## 充足性、完整性以及原始性

?> 概念

经过封装，我们让相互关联的元素集中到一个模块来承载一个抽象概念。该模块承载的抽象概念要具有充足性、完整性和原始性。

- <font color=#42b983>充足性</font>
  - 指模块表达的抽象概念非常充足，比如模块要表达“收集”这一概念，但只提供了remove，没有提供add，这就不足以表达“收集”这一概念了。
- <font color=#42b983>完整性</font>
  - 指模块表达的抽象概念具有所有特征。涵盖所有特征、没有缺漏的模块方便任何人拿去使用。比如当模块要表达“收集”这一概念时，如果模块没有提供用于获取元素个数的size，我们就不能说该抽象概念具有完整性。
- <font color=#42b983>原始性</font>
  - 指模块表达的抽象概念非常精练。比如当模块要表达“收集”这一概念时，如果已经提供了表示添加1个物品的add，则不需要再提供表示添加10个物品的add10。

?> 实践

我们要明确模块要表达的抽象概念。

信息过多或过少都会使信息的传达变得不准确。因此模块提供的函数要满足充足性、完整性和原始性。当出现多余的内容时，要么将其删除，要么将其移至其他模块。

> [!note]
>
> 模块表达的抽象概念必须能向使用者传递有用的信息，准确表达意图
>
> - 缺失充足性：信息就会出现缺失，导致用户看不清模块的本质。人们无法把说不清道不明的模块拿来使用。
> - 缺失完整性：无法让用户安心使用。一旦出现功能不足的情况，工作就难以进行下去。
> - 缺失原始性：模块用起来很麻烦。复杂的接口提升了理解的难度，让人弄不清楚使用时机和使用方法。

## 策略与实现的分离

?> 概念

模块可以承载策略或实现。但是，一个模块不可以同时承载二者。

- <font color=#42b983>策略模块</font>
  - 策略模块依赖于软件的前提条件，这类模块通常用于给业务逻辑或其他模块选择参数。
- <font color=#42b983>实现模块</font>
  - 实现模块不依赖于软件的前提条件，这类模块通常是独立的逻辑部分。软件的前提条件会作为传递给模块的参数给出。

?> 实践

设计时要有意识地区分依赖于软件前提条件的策略部分和不依赖于软件前提条件的实现部分，然后将二者分别写入不同的模块。

当遇到无法分离的情况时，至少要在模块内部明确区分策略部分和实现部分。

另外，即便最初分离了策略与实现，在维护代码的过程中二者也可能会重新混在一起。因此在开展修改工作之前，要明确修改对象到底属于策略还是实现，至少保证实现部分中不会混入策略的相关代码。

> [!note]
>
> 实现模块不依赖于特定的软件，是一种纯粹的模块，因此可供其他软件重复使用。
> 而策略模块是为特定软件量身打造的。当软件发生变动时，策略模块也要被迫发生改变。因此，如果将实现和策略混在一起，那么当策略发生变动时，实现也会受到牵连，影响模块的重复使用。

## 接口与实现的分离

?> 概念

模块由接口和实现这两个相互分离的部分组成。

- <font color=#42b983>接口部分</font>
  - 接口部分用于定义模块具备的功能，决定模块的使用方法。该部分由用户可访问的函数签名组成。
- <font color=#42b983>实现部分</font>
  - 实现部分其实就是实现模块功能的代码部分。该部分包含模块内部使用的逻辑和数据。用户无法访问实现部分。

?> 实践

关于模块的设计原理，有一句“针对接口编程，而不是针对实现编程”的格言。因此，模块之间的调用要保证只使用接口来完成。接口的实现要隐藏在接口背后，该部分不能被直接调用。

## 单一引用点

?> 概念

模块的各元素仅被声明和定义一次。

以变量为例，仅定义一次就是指初始化之后就不再对值进行更改了。这样一来，我们就不用再追踪变量值的变迁过程，代码的可读性也随之提高。

该基本技法可以使编程无副作用。

所谓编程的副作用，是指某一功能使模块状态产生变化，对此后得到的结果造成影响。排除副作用能免去状态的变化，保证相同数据能始终获得相同的结果，从而减少状态依赖引发的故障。

另外，当某一变量被大范围使用且该变量的值被频繁更改时，我们将很难对代码进行追踪。变量值固定则可以省去这些麻烦，从而提高代码的可读性。

?> 实践

单一赋值，是指仅对变量执行一次赋值操作。我们要将副作用视为“应该避免的东西”，把变量看作“不变的东西”，给变量赋值后就不再对其进行更改。

大多数编程语言允许对变量重新赋值，但是我们要跳出语法的限制，通过使用常量、设置规则来禁止重新赋值等方式，编写没有副作用的代码。

> [!note]
>
> 通过控制变量提升代码质量
> 引用透明性
>
> - 调用结果只依赖于参数
>   - 这个特性说的是数学中的函数。给参数传递相同的值总能得到相同的返回值，也就是说，返回值只依赖于参数的值。这种特性称为“单纯性”。
> - 调用不影响其他功能的运行
>   - 这个特性是说函数没有副作用。所谓副作用，是指“某一处理引起状态改变，对此后的处理结果产生影响”。

## 分治

?> 概念

分治是指将难以直接解决的大问题分割成多个小问题，然后逐个解决。

分割后的小问题要比最初的问题简单许多，比较容易解决。各个小问题被逐一解决之后，原来的大问题就不复存在了。

?> 实践

- 在设计整个软件时，先将软件分割成多个可以独立设计的部分，然后对这些部分一一进行设计
- 在设计模块时，按照职责对模块进行分割
- 在设计算法时，可以像归并排序一样，先自下而上地对问题进行分割，再探讨能否解决问题
- 在处理海量数据时，可以像MapReduce一样，先将计算分割成较小的单位，然后探讨能否把这些计算交给分布式环境并行处理

!> 直接解决大问题的话，难度较大，花费的时间也比较多，闹不好到最后问题也解决不了。之所以会出现这样的现象，是因为规模过大的问题，其复杂度也比较高.
