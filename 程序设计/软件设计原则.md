# :no_mouth: **软件设计的原则**

> 在我们尚未给予自己支配本身的力量时，解放我们精神的所有行为，都是百害而无一益的. ——歌德

> 软件设计的原则，是基于[软件设计的原理](程序设计/软件设计的原理.md)而产生。

## **DRY**

> Don't Repeat Yourself

不可以重复写相同的代码，我们可以通过对代码执行抽象化操作来消除重复。

> - WET
> - OFOP(One Fact in One Place)
> - OAOO(Once and Only Once)

## **KISS**

> Keep it Simple

编写代码时，要优先保证代码的简洁性。不管是从零开始编写代码，还是修复故障或扩展功能，都要注意保持代码简洁。

**How:**

- 避免试图使用新学会的技术
- 避免写多余的代码，以备将来之需
- 避免擅自添加需求

> - less is more
> - 奥卡姆剃刀

## **YAGNI**

> You Aren't Going to Need It

不能以“可能会用到”为动机编写代码。我们要在需要的时候写需要的代码。人们不可能预测出软件的变化，写出超前的代码。我们一定要明确这一点，坚持只写当前需要的代码。

**How:**

比起通用性，我们更应该重视单纯性。

先把通用性带来的可重复使用的特性和扩展性放到一边，将“能用”这一点放到第一位。

当在多个设计方案中进行选择时，我们重点要看的是设计方案的单纯性，而不是通用性。不要选择标榜通用性的复杂方案，要选择以具体需求为基础的简单方案。

> - DTSTTCPW（Do The Simplest Thing That Could Possibly Work）

## **Law of Demeter**

## **S.O.L.I.D**

### **SRP**

> Single Responsibility Principle

### **OCP**

> Open/Closed Principle

我们要让代码同时满足对扩展开放、对修改关闭这两个属性。

**How:**

给代码添加接口。

> - 面向对象的多态性是实现OCP的代表技术
> - GRASP(General Responsibility Assignment Software Pattern，通用职责分配软件模式)

### **LSP**

> Liskov substitution principle

### **ISP**

> Interface Segregation Principle

### **DIP**

> Dependency Inversion Principle

## **CCP**

> Common Closure Principle

## **CRP**

> Common Reuse Principle

## **Hollywood Principle**

## **High Cohesion & Low/Loose coupling**

**内聚度（High Cohesion）：**

内聚度用于表示模块内功能的纯粹程度，用来衡量模块的强度。

内聚度的强度分为七个等级。等级越高的模块越纯粹，强度也越高，质量也越好。

**level-1 巧合强度：**

在巧合强度模块中，各元素之间并不存在特别的关系。“巧合”指事物恰巧一致。

**level-2 逻辑强度：**

逻辑强度模块指抽象地整合了某种功能的模块。

这种模块内的逻辑会根据条件来选择不同的执行路径。也就是说，逻辑强度模块包含了几种相互关联的功能，调用模块会识别其中一种来执行。

所以，这种模块被调用时只会执行其中一部分命令，不会执行模块内的所有命令。模块内部命令群的关联性会变弱，模块强度会变小。

另外，不同的功能只能使用同一个接口（输入输出参数）与调用方模块联系。因此，参数的操作方面容易出现编程错误。

不过，逻辑强度也具有以下优点：

- 这种模块包含多个共同的功能。部分逻辑可以实现共享
- 首先，这种模块包含多个共同的功能。部分逻辑可以实现共享
- 特定数据的处理能够集中在一个模块内进行。也就是说，逻辑强度模块有着良好的信息隐蔽性

**level-3 时间强度：**

时间强度模块由在特定的时间点连续执行的多个功能整合而成。模块内各功能之间不存在很强的关联性，它们只是在特定的时间点被连续执行而已。

**level-4 流程强度：**

流程强度模块由处理问题时所需的全部或部分功能组合而成。

这些功能按顺序执行。一般来说，流程强度模块具有时间强度模块的特性，但由于流程强度模块的各功能之间具有流程方面的关联性，所以这类模块的内聚度比时间强度模块的内聚度要高。

**level-5 通信强度：**

通信强度模块基本拥有流程强度模块的特性。

与流程强度的模块不同的是，这种模块内部的各功能之间会进行数据的传递（通信）或引用相同的数据。在通信强度模块中，因为功能在数据上存在联系，所以通信强度模块的内聚度要高于流程强度模块的内聚度。

**level-6 信息强度：**

信息强度模块由处理特定数据结构的多个功能组成。

这种模块的基本思想是同一种数据结构（信息）尽量由同一个模块来访问。这样一来，修改数据所带来的影响将限制在相应的模块内，从信息隐藏的角度来说有一定的好处。

信息强度 VS 逻辑强度：

- 逻辑强度模块只有一个接入点，执行的功能要靠参数来选择。
- 信息强度有多个接入点，各接入点执行单一的固定的功能。各个接入点拥有自己的参数，因此这类模块不存在逻辑强度模块中参数难以处理的缺点。

**level-7 功能强度：**

在功能强度模块内，所有命令都为了完成一项工作（功能）而相互关联。这类模块是纯粹度最高的模块。

功能强度模块可以将修改限制在该模块内部。这类模块对其他模块的影响程度比其他强度的模块要小。

**How：**

为了提高模块的独立性，我们要尽量实现功能强度模块，但也要根据不同的情况，选择不同的内聚强度。

> 高内聚的优点：
>
> - 使代码的设计更加明确，更容易让人理解。
> - 代码易于维护和扩展。
> - 促进代码的重复使用。
> - 促进代码之间的低耦合性。

-----

**耦合度（Low/Loose coupling）：**

耦合度是衡量模块之间关系紧密程度的标准。耦合度测量的是两个模块之间耦合的松紧程度。

耦合度的判定要着眼于模块间如何传递数据。

**level-1 内容耦合：**

内容耦合指模块与其他模块存在共享部分。

内容耦合不会出现在使用高级语言编写的模块中，但常在使用汇编语言编写的模块里出现。

**level-2 公共耦合：**

公共耦合指在公共区域内定义的数据由多个模块共同使用。

公共区域内定义的数据就是全局变量。

公共耦合的弊端：

- 公共区域的数据不会出现在模块间的接口上，这使得代码不容易被解读
- 因为公共区域的数据可以供毫无关系的模块使用，所以代码的安全性较低
- 公共耦合的模块通过公共区域的数据与许多模块发生关联，阻碍了代码的重复使用

使用公共耦合也带来一些好处，就是减少不同模块间的参数传递。

然而，采用了不恰当的模块设计才是需要大量参数传递数据的主要原因。通过重新设计模块，再次审查数据的位置，参数的数量大多能够减少。

**level-3 外部耦合：**

外部耦合指模块间共享外部声明的数据。

外部声明的定义，举例来说就是public声明的函数。

从共享数据的意义上讲，外部耦合与公共耦合有相似之处。不过，外部耦合只外部声明有用的数据，所以不会像公共耦合那样连没有用的数据都共享。从这一点来说，外部耦合的耦合度要低于公共耦合的耦合度。

**level-4 控制耦合：**

控制耦合指调用方模块以参数的形式传递涉及被调用方模块内部控制的数据。

在控制耦合的模式下，调用方模块以参数的形式将选择变量传递给被调用方模块，从而指示被调用方执行相应的功能。因此，调用方必须知道被调用方模块的逻辑，不能将对方当作黑箱。这就增强了耦合度。

控制耦合还有一个缺点，那就是被调用方模块的内聚度会达到逻辑强度。不过，因为不会共享数据，所以控制耦合的耦合度要低于公共耦合和外部耦合的耦合度。

**level-5 特征耦合：**

特征耦合指两个模块间传递公共区域中没有的数据结构。

在特征耦合的模式下，传递的数据结构并不是都能用到的。这一点提高了特征耦合的耦合度。

**level-6 数据耦合：**

数据耦合指模块间仅通过参数传递标量类型的数据作为模块间的接口。

因为可以将对象模块视为黑箱，所以数据耦合的耦合度最低。

在模块间的耦合中，通过明确的参数传递数据的数据耦合最为优秀。

值得一提的是，特征耦合传递的是数据结构，并且只使用其中一部分数据结构。如果接收数据的一方会处理数据结构中的所有数据，那么这种耦合也可以视为数据耦合。

**How：**

为了提高模块的独立性，我们要尽量降低模块间接口的耦合度。

- 尽量通过参数传递数据
- 数据尽量不用全局变量保存。只用一次的数据存放在局部变量里
- 不让模块的运行因外界传来的值而发生改变。如果参数传来的标志位内容是“A”就执行添加，是“D”就执行删除，那么模块的耦合度就会变高

> - 混合耦合: 混合耦合表示数据在不同状态下可以存在多重意义。
> - 耦合的个数与方向: 对于耦合度，我们需要关注“强度”、“松紧程度”、“个数”与“方向”。
> - 幂等性：幂等性是数学术语，表示对于某操作，无论执行多少次都会得到相同的结果。同一个函数无论被调用多少次，得到的结果都是一样的。
> - 安全性：指不让操作对象的状态发生变化。而副作用表示使状态发生变化，所以安全性还可以说成“对操作对象的状态没有副作用”。

## **CoC**

> Convention over Configuration

## **SoC**

> Separation of Concerns

## **DbC**

> Design by Contract

## **ADP**

> Acyclic Dependencies Principle

## **PIE**

> Program Intently and Expressively

在写代码时，明确表达意图十分重要。

这是因为代码是写给人看的，而不是写给编译器看的。因此，在写代码时要在表达上多花心思，将软件运行方式直观地传达给阅读代码的人。

**How:**

- 在编写代码时，我们要重视的是代码的可读性，而不是代码的易写性。
- 将代码的可读性放在第一位，就意味着不能为了炫耀才华而写一些让人难懂的代码。
- 不管是自己写的代码还是别人写的代码，只要我们在阅读的过程中不能立刻理解，就应该马上对其进行修改，提高代码的可读性。

> - 避免打地鼠式的开发
> - 要写注释——表达“为什么这样做”
> - 文学编程——一种将代码本身当作文档的编程方法

## **SLAP**

> Single Level of Abstraction Principle

在编写代码时，我们要将高级别的抽象化概念和低级别的抽象化概念分离。在分离时不能只有高低两层。我们要根据功能的复杂程度对抽象化概念进行分离，然后统一各层的抽象级别。

也就是说，我们要根据抽象级别对函数进行分割，并且将同一函数中的代码统一为同一个抽象级别。

**How:**

将函数结构化

> - 参考写文章时的步骤来实现SLAP

## **Extends Principle**

- 正交性
- 可逆性
- 童子军规则
