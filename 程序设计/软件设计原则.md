# 软件设计的原则

> :pencil2: 在我们尚未给予自己支配本身的力量时，解放我们精神的所有行为，都是百害而无一益的. ——歌德

## DRY

?> 概念

Don't Repeat Yourself，不可以重复写相同的代码，我们可以通过对代码执行抽象化操作来消除重复。

重复代码的表现：

- 实现逻辑重复
- 功能语义重复
- 代码执行重复

但，实现逻辑重复，功能语义不重复，并不会违反DRY原则。

> [!tip|label:关联原则]
>
> - WET
> - OFOP(One Fact in One Place)
> - OAOO(Once and Only Once)

## KISS

?> 概念

keep it simple & keep it short，编写代码时，要优先保证代码的简洁性。不管是从零开始编写代码，还是修复故障或扩展功能，都要注意保持代码简洁。

?> 实践

- 避免试图使用新学会的技术
- 避免写多余的代码，以备将来之需
- 避免擅自添加需求

> [!tip|label:关联原则]
>
> - less is more
> - 奥卡姆剃刀

## YAGNI

?> 概念

You Aren't Going to Need It, 不能以“可能会用到”为动机编写代码。我们要在需要的时候写需要的代码。人们不可能预测出软件的变化，写出超前的代码。我们一定要明确这一点，坚持只写当前需要的代码。

?> 实践

比起通用性，我们更应该重视单纯性。

先把通用性带来的可重复使用的特性和扩展性放到一边，将“能用”这一点放到第一位。

当在多个设计方案中进行选择时，我们重点要看的是设计方案的单纯性，而不是通用性。不要选择标榜通用性的复杂方案，要选择以具体需求为基础的简单方案。

> [!tip|label:关联原则]
>
> - DTSTTCPW（Do The Simplest Thing That Could Possibly Work）

## Law of Demeter

?> 概念

每个模块只应该了解那些与它关系密切的模块的有限知识，也就是说，每个模块只何自己的朋友说话，不和陌生人交谈。

?> 实践

从类的层面来解读，也就是说，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。

## S.O.L.I.D

### SRP


?> 概念 

Single Responsibility Principle，单一职责原则规定一个类或一个模块只负责完成一个职责（或功能），职责也可以理解为“改变的原因”，也就是一个类或者模块应该有且只有一个改变的原因。

也就是说，我们在设计类的时候，要设计粒度小、功能单一的类，目的是为了实现代码高内聚、低耦合、提高复用性、可读性和可维护性。但是，不同的应用场景、不同阶段的请求、不同的业务层面，对于同一个类的职责是否单一，可能会有不同的判定结果。

?> 实践

实际上，一些侧面的判断指标更具有指导意义和可执行性，如：

- 类的代码行数、函数或者属性过多
- 类依赖的其他类过多，或者依赖类的其他类过多
- 私有方法过多
- 比较难给类起一个合适的名字
- 类中大量的方法都是集中操作类中的某几个属性

!> 避免过度拆分，适得其反，导致内聚性降低，影响代码的可读性。

### OCP

?> 概念

Open/Closed Principle,我们要让代码同时满足对扩展开放、对修改关闭这两个属性。也就说，添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有的代码的方式来完成。

有以下几点需要注意：

- 开闭原则并不是说完成杜绝修改，而是以最小修改代码的代价完成新功能开发
- 同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”

?> 实践

- 给代码添加接口
- 时刻具备扩展意识、抽象意识、封装意识
- 编写代码时，多花时间思考，这段代码未来可能又哪些需求变更，如何设计代码结构，事先留好扩展点。

> [!tip|label:关联原则]
>
> - 面向对象的多态性是实现OCP的代表技术
> - GRASP(General Responsibility Assignment Software Pattern，通用职责分配软件模式)

### LSP

?> 概念

Liskov substitution principle,里氏替换原则，子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为，正确性不被破坏。

违反该原则的几个例子：

- 子类违背父类声明要实现的功能
- 子类违背父类对输入、输出、异常的约定
- 子类违背父类注释中所罗列的任何特殊说明

### ISP

?> 概念

Interface Segregation Principle,接口隔离原则，客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。

?> 实践

根据该原则，接口可以理解为以下几种情况：

- 一组API接口集合：它可以式某个微服务的接口，也可以是某个类库的接口等。如果这部分接口只被部分调用者使用，就需要将这部分接口隔离出来。
- 单个API接口或函数：部分调用者只需要函数中的部分功能，那就需要把函数拆分成粒度更细的多个函数。
- OOP中的接口概念：接口的设计尽量单一。

> [!note|label:ISP vs SRP]
>
> - SRP针对的是模块、类、接口的设计，而ISP侧重于接口的设计，思考的角度不一致
> - ISP提供了一钟判断接口的职责是否单一的标准

### DIP

?> 概念

Dependency Inversion Principle,依赖反转原则，主要用来指导框架层面的设计，高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

## CCP

?> 概念

Common Closure Principle

## CRP

?> 概念

Common Reuse Principle

## Hollywood Principle

## High Cohesion & Low/Loose coupling

### 内聚度(High Cohesion)

?> 概念

内聚度用于表示模块内功能的纯粹程度，用来衡量模块的强度。

内聚度的强度分为七个等级。等级越高的模块越纯粹，强度也越高，质量也越好。

?> _level 1_ 巧合强度

在巧合强度模块中，各元素之间并不存在特别的关系。“巧合”指事物恰巧一致。

?> _level 2_ 逻辑强度

逻辑强度模块指抽象地整合了某种功能的模块。

这种模块内的逻辑会根据条件来选择不同的执行路径。也就是说，逻辑强度模块包含了几种相互关联的功能，调用模块会识别其中一种来执行。

所以，这种模块被调用时只会执行其中一部分命令，不会执行模块内的所有命令。模块内部命令群的关联性会变弱，模块强度会变小。

另外，不同的功能只能使用同一个接口（输入输出参数）与调用方模块联系。因此，参数的操作方面容易出现编程错误。

不过，逻辑强度也具有以下优点：

- 这种模块包含多个共同的功能。部分逻辑可以实现共享
- 首先，这种模块包含多个共同的功能。部分逻辑可以实现共享
- 特定数据的处理能够集中在一个模块内进行。也就是说，逻辑强度模块有着良好的信息隐蔽性

?> _level 3_ 时间强度

时间强度模块由在特定的时间点连续执行的多个功能整合而成。模块内各功能之间不存在很强的关联性，它们只是在特定的时间点被连续执行而已。

?> _level 4_ 流程强度

流程强度模块由处理问题时所需的全部或部分功能组合而成。

这些功能按顺序执行。一般来说，流程强度模块具有时间强度模块的特性，但由于流程强度模块的各功能之间具有流程方面的关联性，所以这类模块的内聚度比时间强度模块的内聚度要高。

?> _level 5_ 通信强度

通信强度模块基本拥有流程强度模块的特性。

与流程强度的模块不同的是，这种模块内部的各功能之间会进行数据的传递（通信）或引用相同的数据。在通信强度模块中，因为功能在数据上存在联系，所以通信强度模块的内聚度要高于流程强度模块的内聚度。

?> _level 6_ 信息强度

信息强度模块由处理特定数据结构的多个功能组成。

这种模块的基本思想是同一种数据结构（信息）尽量由同一个模块来访问。这样一来，修改数据所带来的影响将限制在相应的模块内，从信息隐藏的角度来说有一定的好处。

信息强度 VS 逻辑强度：

- 逻辑强度模块只有一个接入点，执行的功能要靠参数来选择。
- 信息强度有多个接入点，各接入点执行单一的固定的功能。各个接入点拥有自己的参数，因此这类模块不存在逻辑强度模块中参数难以处理的缺点。

?> _level 7_ 功能强度

在功能强度模块内，所有命令都为了完成一项工作（功能）而相互关联。这类模块是纯粹度最高的模块。

功能强度模块可以将修改限制在该模块内部。这类模块对其他模块的影响程度比其他强度的模块要小。

?> 实践

为了提高模块的独立性，我们要尽量实现功能强度模块，但也要根据不同的情况，选择不同的内聚强度。

> [!note|label:高内聚的优点]
>
> - 使代码的设计更加明确，更容易让人理解。
> - 代码易于维护和扩展。
> - 促进代码的重复使用。
> - 促进代码之间的低耦合性。


### 耦合度(Low/Loose coupling)

?> 概念

耦合度是衡量模块之间关系紧密程度的标准。耦合度测量的是两个模块之间耦合的松紧程度。

耦合度的判定要着眼于模块间如何传递数据。

?> _level 1_ 内容耦合

内容耦合指模块与其他模块存在共享部分。

内容耦合不会出现在使用高级语言编写的模块中，但常在使用汇编语言编写的模块里出现。

?> _level 2_ 公共耦合

公共耦合指在公共区域内定义的数据由多个模块共同使用。

公共区域内定义的数据就是全局变量。

公共耦合的弊端：

- 公共区域的数据不会出现在模块间的接口上，这使得代码不容易被解读
- 因为公共区域的数据可以供毫无关系的模块使用，所以代码的安全性较低
- 公共耦合的模块通过公共区域的数据与许多模块发生关联，阻碍了代码的重复使用

使用公共耦合也带来一些好处，就是减少不同模块间的参数传递。

然而，采用了不恰当的模块设计才是需要大量参数传递数据的主要原因。通过重新设计模块，再次审查数据的位置，参数的数量大多能够减少。

?> _level 3_ 外部耦合

外部耦合指模块间共享外部声明的数据。

外部声明的定义，举例来说就是public声明的函数。

从共享数据的意义上讲，外部耦合与公共耦合有相似之处。不过，外部耦合只外部声明有用的数据，所以不会像公共耦合那样连没有用的数据都共享。从这一点来说，外部耦合的耦合度要低于公共耦合的耦合度。

?> _level 4_ 控制耦合

控制耦合指调用方模块以参数的形式传递涉及被调用方模块内部控制的数据。

在控制耦合的模式下，调用方模块以参数的形式将选择变量传递给被调用方模块，从而指示被调用方执行相应的功能。因此，调用方必须知道被调用方模块的逻辑，不能将对方当作黑箱。这就增强了耦合度。

控制耦合还有一个缺点，那就是被调用方模块的内聚度会达到逻辑强度。不过，因为不会共享数据，所以控制耦合的耦合度要低于公共耦合和外部耦合的耦合度。

?> _level 5_ 特征耦合

特征耦合指两个模块间传递公共区域中没有的数据结构。

在特征耦合的模式下，传递的数据结构并不是都能用到的。这一点提高了特征耦合的耦合度。

?> _level 6_ 数据耦合

数据耦合指模块间仅通过参数传递标量类型的数据作为模块间的接口。

因为可以将对象模块视为黑箱，所以数据耦合的耦合度最低。

在模块间的耦合中，通过明确的参数传递数据的数据耦合最为优秀。

值得一提的是，特征耦合传递的是数据结构，并且只使用其中一部分数据结构。如果接收数据的一方会处理数据结构中的所有数据，那么这种耦合也可以视为数据耦合。

?> 实践

为了提高模块的独立性，我们要尽量降低模块间接口的耦合度。

- 尽量通过参数传递数据
- 数据尽量不用全局变量保存。只用一次的数据存放在局部变量里
- 不让模块的运行因外界传来的值而发生改变。如果参数传来的标志位内容是“A”就执行添加，是“D”就执行删除，那么模块的耦合度就会变高

> [!tip|label:关联原则]
>
> - 混合耦合: 混合耦合表示数据在不同状态下可以存在多重意义。
> - 耦合的个数与方向: 对于耦合度，我们需要关注“强度”、“松紧程度”、“个数”与“方向”。
> - 幂等性：幂等性是数学术语，表示对于某操作，无论执行多少次都会得到相同的结果。同一个函数无论被调用多少次，得到的结果都是一样的。
> - 安全性：指不让操作对象的状态发生变化。而副作用表示使状态发生变化，所以安全性还可以说成“对操作对象的状态没有副作用”。

## CoC

?> 概念

Convention over Configuration

## SoC

?> 概念

Separation of Concerns

## DbC

?> 概念

Design by Contract

## ADP

?> 概念

Acyclic Dependencies Principle

## PIE

?> 概念

Program Intently and Expressively

在写代码时，明确表达意图十分重要。

这是因为代码是写给人看的，而不是写给编译器看的。因此，在写代码时要在表达上多花心思，将软件运行方式直观地传达给阅读代码的人。

?> 实践

- 在编写代码时，我们要重视的是代码的可读性，而不是代码的易写性。
- 将代码的可读性放在第一位，就意味着不能为了炫耀才华而写一些让人难懂的代码。
- 不管是自己写的代码还是别人写的代码，只要我们在阅读的过程中不能立刻理解，就应该马上对其进行修改，提高代码的可读性。

> [!tip|label:关联原则]
>
> - 避免打地鼠式的开发
> - 要写注释——表达“为什么这样做”
> - 文学编程——一种将代码本身当作文档的编程方法

## SLAP

?> 概念

Single Level of Abstraction Principle,在编写代码时，我们要将高级别的抽象化概念和低级别的抽象化概念分离。在分离时不能只有高低两层。我们要根据功能的复杂程度对抽象化概念进行分离，然后统一各层的抽象级别。

也就是说，我们要根据抽象级别对函数进行分割，并且将同一函数中的代码统一为同一个抽象级别。

?> 实践

将函数结构化

> [!tip|label:关联原则]
>
> - 参考写文章时的步骤来实现SLAP

## Extends Principle

- 正交性
- 可逆性
- 童子军规则
