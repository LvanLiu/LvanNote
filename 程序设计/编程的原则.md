# :no_mouth: 编程的原则

## 准则

> 在我们尚未给予自己支配本身的力量时，解放我们精神的所有行为，都是百害而无一益的. ——歌德

### KISS

> Keep it  Simple, Stupid or Keep it short and Simple

**What** :question:

编写代码时，要优先保证代码的简洁性。

不管是从零开始编写代码，还是修复故障或扩展功能，都要注意保持代码简洁。

**How** :question:

- 避免试图使用新学会的技术
- 避免写多余的代码，以备将来之需
- 擅自添加需求

> [!note]
>
> - less is more
> - 奥卡姆剃刀

### DRY

> Don't Repeat Yourself

**What** :question:

不可以重复写相同的代码。

**How** :question:

我们可以通过对代码执行抽象化操作来消除重复。

> [!note]
>
> - WET
> - OFOP(One Fact in One Place)
> - OAOO(Once and Only Once)

### YAGNI

> You Aren't Going to Need It

**What** :question:

不能以“可能会用到”为动机编写代码。我们要在需要的时候写需要的代码。

人们不可能预测出软件的变化，写出超前的代码。我们一定要明确这一点，坚持只写当前需要的代码。

**How** :question:

比起通用性，我们更应该重视单纯性。

先把通用性带来的可重复使用的特性和扩展性放到一边，将“能用”这一点放到第一位。

当在多个设计方案中进行选择时，我们重点要看的是设计方案的单纯性，而不是通用性。不要选择标榜通用性的复杂方案，要选择以具体需求为基础的简单方案。

> [!note]
>
> - DTSTTCPW（Do The Simplest Thing That Could Possibly Work）

### PIE

> Program Intently and Expressively

**What** :question:

在写代码时，明确表达意图十分重要。

这是因为代码是写给人看的，而不是写给编译器看的。因此，在写代码时要在表达上多花心思，将软件运行方式直观地传达给阅读代码的人。

**How** :question:

- 在编写代码时，我们要重视的是代码的可读性，而不是代码的易写性。
- 将代码的可读性放在第一位，就意味着不能为了炫耀才华而写一些让人难懂的代码。
- 不管是自己写的代码还是别人写的代码，只要我们在阅读的过程中不能立刻理解，就应该马上对其进行修改，提高代码的可读性。

> [!note]
>
> - 避免打地鼠式的开发
> - 要写注释——表达“为什么这样做”
> - 文学编程——一种将代码本身当作文档的编程方法

### SLAP

> Single Level of Abstraction Principle

**What** :question:

在编写代码时，我们要将高级别的抽象化概念和低级别的抽象化概念分离。

在分离时不能只有高低两层。我们要根据功能的复杂程度对抽象化概念进行分离，然后统一各层的抽象级别。

也就是说，我们要根据抽象级别对函数进行分割，并且将同一函数中的代码统一为同一个抽象级别。

**How** :question:

将函数结构化

> [!note]
>
> - 参考写文章时的步骤来实现SLAP

### OCP

>  Open-Closed Principle

**What** :question:

我们要让代码同时满足对扩展开放、对修改关闭这两个属性。

**How** :question:

给代码添加接口。

> [!note]
>
> - 面向对象的多态性是实现OCP的代表技术
> - GRASP(General Responsibility Assignment Software Pattern，通用职责分配软件模式)

## 编写的意识形态

> 少数拥有特殊嗅觉的人能够发现全新事物，
> 但他们并非有独创性的人。
> 真正有独创性的人拥有一双慧眼，
> 他们能将众人眼中的旧事物、人尽皆知的事物，
> 大多数人觉得不值一提、熟视无睹的事物，
> 视作崭新的事物。
> ——尼采

### 思想：交流

**What** :question:

代码也是一种给人看的文档，而文档的本质在于交流。

在编程中，良好的交流意味着读代码的人能够理解、修改和使用代码。

**How** :question:

要想通过代码取得良好的交流效果，我们在写代码时就得站在代码阅读者的角度思考。

### 思想：简洁

**What** :question:

对代码而言，简洁就是消除了“多余的复杂性”后的状态。这里所说的“多余的复杂性”不是指反映了目标（代码要达成的目的）复杂程度的复杂性，而是指在修改代码的过程中遗留下来的痕迹所带来的复杂性。

**How** :question:

要想让代码保持简洁，我们就需要将代码中的“玉”与“石”明确区分开来。在设计时，将代码的本质部分（玉）放在显眼的位置，保证其他元素（石）不会混入其中。

不过，简洁与交流偶尔也会发生冲突。过度简洁会使代码变得难以理解。在遇到这种情况时，我们就需要牺牲一部分简洁性，把交流放在优先的位置。

### 思想：灵活性

**What** :question:

代码的灵活性是指修改代码的难易程度。

“灵活”是指在添加新代码的时候，已有代码能够不受影响、不产生冲突、不出现排斥，在保证自身不遭到破坏的前提下灵活地接纳新代码。

**How** :question:

要想让代码具有灵活性，就要保证代码易于扩展且扩展时不会波及无关的元素。

为了写出灵活且简洁的代码，我们需要克制住展现小技巧的欲望。相较于通过设计自上而下地获取灵活性，从确保简洁出发，通过单元测试自下而上地获取灵活性会更好。

> [!note]
> 
> 代码必然会被修改

### 原则：效应局部化

**What** :question:

效应局部化中的“效应”是指修改带来的影响。

效应局部化是指将修改带来的影响控制在局部。

效应局部化是一个很重要的原则。围绕该原则产生了许多技术，模块化就是其中之一。模块化技术的目标之一就是让修改模块所带来的影响停留在该模块的内部。

**How** :question:

在编写代码时，要让关系紧密的代码集中在一起，同时保证关联性较弱的代码不互相依赖。为此，我们需要将关系紧密的代码集中起来实现模块化。

从关联性的角度来看，我们要格外注意相互频繁调用的模块。模块之间相互频繁调用通常表明原本应该放在一起的要素被分别放在了不同的模块中。

这种时候就需要让合适的单一模块来实现功能，或者将模块功能整合在一起，或者重新创建一个模块来实现相应的功能，总之要保证单一功能的密集性。

> [!note]
> 
> 在效应局部化的情况下，我们需要阅读的代码以及修改所带来的影响都会限制在一定的范围内。

### 原则：重复最小化

**What** :question:

重复最少化，就是指极力消除重复。

许多技术都以实现重复最少化为目标，函数化技术就是其中之一。该技术将重复的逻辑函数化，整合成一段共享代码来使用。

**How** :question:

我们要将代码分割成多个小块。

大块代码之间一般会存在重复的部分。将大块代码分割成多个小块之后，就能轻松找出共同的部分了。

将代码分割成多个小块后，要明确代码内哪些地方是完全一样的，哪些地方是相似的，哪些地方是完全不同的。只要区分清楚这些，代码的可读性就会提高，修改成本也会下降。

> [!note]
> 
> 重复违反了效应局部化原则。

### 原则：逻辑与数据的一体化

**What** :question:

逻辑与数据的一体化是指把逻辑和该逻辑处理的数据放在相近的位置。

所谓相近的位置，指的是在同一函数或同一模块内。距离越近，代码的质量就越高。

**How** :question:

我们要把数据与逻辑放在相近的位置。

不过，我们很难一开始就知道哪个逻辑应该和哪些数据放在一起。这时不妨先大致安排一下，之后再根据具体情况进行调整。

编写、运行代码之后，数据与逻辑的关联性会渐渐显露出来。是让代码靠近数据，还是让数据靠近代码；是将代码和数据取出来放到其他位置，还是不进行任何变动……对于这些问题，我们会在不断尝试的过程中逐渐了解具体的做法。

> [!note]
> 
> 修改代码时往往需要同时修改逻辑与该逻辑处理的数据。因此，如果把二者放在同一位置，我们要阅读的代码就会减少，修改也不会波及其他元素。从结果来看，这么做降低了修改成本。

### 原则：对称性

**What** :question:

对称性一般指事物中对某种变换保持不变的性质。

编程中的对称性是指相同的思路在代码的任何地方都以相同的形式表现出来。

简单来说，就是组内的等级整理。同类的东西，也就是拥有相同性质的东西，要使用相同的等级来表现。

**How** :question:

在编写代码的时候，同类的东西要用相同的形式表现，例如：

- 如果有“添加”方法，就创建与之相对的“删除”方法
- 同组的函数用相同的参数
- 让同一个模块里的数据拥有相同的生存周期
- 函数内所有调用函数的抽象级别要相同

> [!note]
> 
> 在代码中明确表现出对称性后，代码的可读性将大幅提高。

### 原则：声明式编程

**What** :question:

声明式表达是指在表达代码意图时，尽量用“声明式”的表达方式，而非“命令式”的表达方式。

命令式编程描述的是问题的解决方法，也就是数据结构与算法。而声明式编程描述的是问题的定义，也就是当前问题的性质及解决问题时应满足的限制条件。

**How** :question:

我们要采用声明式的表达方式，简洁地表达意图。

当编程范式使用了声明式语言时，由于编写出的代码是声明式的，所以不用我们去特别注意什么。

另一方面，当编程范式使用了命令式语言时，我们也要在代码中合适的部分使用声明式表达，以获取声明式带来的优势。

### 原则：变动率

**What** :question:

变动率体现了修改代码的时间点，变动率相同意味着代码在同一时间点被修改。同时修改的元素要放在同一个地方，在不同时间点修改的元素要放在不同的地方。

**How** :question:

修改时间相同的元素要放在同一个地方，修改时间不同的元素要放在不同的地方。这对逻辑和数据来说都适用。

> [!note]
> 
> - 如果模块只存在一个修改理由，就代表该模块由关联性极强的代码集合而成。这类模块满足高聚合性，非常牢固
> - 单一职责原则


