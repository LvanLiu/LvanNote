# :no_mouth: 程序员的自我修养

> 身上缺点太多固然是一件坏事，但是满身缺点却又不愿意承认，那就更不好了。——帕斯卡

## 内聚度

**What** :question:

内聚度用于表示模块内功能的纯粹程度，用来衡量模块的强度。

内聚度的强度分为七个等级。等级越高的模块越纯粹，强度也越高，质量也越好。

### level-1 巧合强度

在巧合强度模块中，各元素之间并不存在特别的关系。“巧合”指事物恰巧一致。

### level-2 逻辑强度

逻辑强度模块指抽象地整合了某种功能的模块。

这种模块内的逻辑会根据条件来选择不同的执行路径。也就是说，逻辑强度模块包含了几种相互关联的功能，调用模块会识别其中一种来执行。

所以，这种模块被调用时只会执行其中一部分命令，不会执行模块内的所有命令。模块内部命令群的关联性会变弱，模块强度会变小。

另外，不同的功能只能使用同一个接口（输入输出参数）与调用方模块联系。因此，参数的操作方面容易出现编程错误。

不过，逻辑强度也具有以下优点：

- 这种模块包含多个共同的功能。部分逻辑可以实现共享
- 首先，这种模块包含多个共同的功能。部分逻辑可以实现共享
- 特定数据的处理能够集中在一个模块内进行。也就是说，逻辑强度模块有着良好的信息隐蔽性

### level-3 时间强度

时间强度模块由在特定的时间点连续执行的多个功能整合而成。模块内各功能之间不存在很强的关联性，它们只是在特定的时间点被连续执行而已。

### level-4 流程强度

流程强度模块由处理问题时所需的全部或部分功能组合而成。

这些功能按顺序执行。一般来说，流程强度模块具有时间强度模块的特性，但由于流程强度模块的各功能之间具有流程方面的关联性，所以这类模块的内聚度比时间强度模块的内聚度要高。

### level-5 通信强度

通信强度模块基本拥有流程强度模块的特性。

与流程强度的模块不同的是，这种模块内部的各功能之间会进行数据的传递（通信）或引用相同的数据。在通信强度模块中，因为功能在数据上存在联系，所以通信强度模块的内聚度要高于流程强度模块的内聚度。

### level-6 信息强度

信息强度模块由处理特定数据结构的多个功能组成。

这种模块的基本思想是同一种数据结构（信息）尽量由同一个模块来访问。这样一来，修改数据所带来的影响将限制在相应的模块内，从信息隐藏的角度来说有一定的好处。

信息强度 VS 逻辑强度：

- 逻辑强度模块只有一个接入点，执行的功能要靠参数来选择。
- 信息强度有多个接入点，各接入点执行单一的固定的功能。各个接入点拥有自己的参数，因此这类模块不存在逻辑强度模块中参数难以处理的缺点。

### level-7 功能强度

在功能强度模块内，所有命令都为了完成一项工作（功能）而相互关联。这类模块是纯粹度最高的模块。

功能强度模块可以将修改限制在该模块内部。这类模块对其他模块的影响程度比其他强度的模块要小。

**How** :question:

为了提高模块的独立性，我们要尽量实现功能强度模块，但也要根据不同的情况，选择不同的内聚强度。

> [!note]
>
> 高内聚的优点：
> 
> - 使代码的设计更加明确，更容易让人理解。
> - 代码易于维护和扩展。
> - 促进代码的重复使用。
> - 促进代码之间的低耦合性。

## 耦合度

**What** :question:

耦合度是衡量模块之间关系紧密程度的标准。耦合度测量的是两个模块之间耦合的松紧程度。

耦合度的判定要着眼于模块间如何传递数据。

### level-1 内容耦合

内容耦合指模块与其他模块存在共享部分。

内容耦合不会出现在使用高级语言编写的模块中，但常在使用汇编语言编写的模块里出现。

### level-2 公共耦合

公共耦合指在公共区域内定义的数据由多个模块共同使用。

公共区域内定义的数据就是全局变量。

公共耦合的弊端：

- 公共区域的数据不会出现在模块间的接口上，这使得代码不容易被解读
- 因为公共区域的数据可以供毫无关系的模块使用，所以代码的安全性较低
- 公共耦合的模块通过公共区域的数据与许多模块发生关联，阻碍了代码的重复使用

使用公共耦合也带来一些好处，就是减少不同模块间的参数传递。

然而，采用了不恰当的模块设计才是需要大量参数传递数据的主要原因。通过重新设计模块，再次审查数据的位置，参数的数量大多能够减少。

### level-3 外部耦合

外部耦合指模块间共享外部声明的数据。

外部声明的定义，举例来说就是public声明的函数。

从共享数据的意义上讲，外部耦合与公共耦合有相似之处。不过，外部耦合只外部声明有用的数据，所以不会像公共耦合那样连没有用的数据都共享。从这一点来说，外部耦合的耦合度要低于公共耦合的耦合度。

### level-4 控制耦合

控制耦合指调用方模块以参数的形式传递涉及被调用方模块内部控制的数据。

在控制耦合的模式下，调用方模块以参数的形式将选择变量传递给被调用方模块，从而指示被调用方执行相应的功能。因此，调用方必须知道被调用方模块的逻辑，不能将对方当作黑箱。这就增强了耦合度。

控制耦合还有一个缺点，那就是被调用方模块的内聚度会达到逻辑强度。不过，因为不会共享数据，所以控制耦合的耦合度要低于公共耦合和外部耦合的耦合度。

### level-5 特征耦合

特征耦合指两个模块间传递公共区域中没有的数据结构。

在特征耦合的模式下，传递的数据结构并不是都能用到的。这一点提高了特征耦合的耦合度。

### level-6 数据耦合

数据耦合指模块间仅通过参数传递标量类型的数据作为模块间的接口。

因为可以将对象模块视为黑箱，所以数据耦合的耦合度最低。

在模块间的耦合中，通过明确的参数传递数据的数据耦合最为优秀。

值得一提的是，特征耦合传递的是数据结构，并且只使用其中一部分数据结构。如果接收数据的一方会处理数据结构中的所有数据，那么这种耦合也可以视为数据耦合。

**How** :question:

为了提高模块的独立性，我们要尽量降低模块间接口的耦合度。

- 尽量通过参数传递数据
- 数据尽量不用全局变量保存。只用一次的数据存放在局部变量里
- 不让模块的运行因外界传来的值而发生改变。如果参数传来的标志位内容是“A”就执行添加，是“D”就执行删除，那么模块的耦合度就会变高

> [!note]
>
> 混合耦合: 混合耦合表示数据在不同状态下可以存在多重意义。
> 耦合的个数与方向: 对于耦合度，我们需要关注“强度”、“松紧程度”、“个数”与“方向”。
> 幂等性：幂等性是数学术语，表示对于某操作，无论执行多少次都会得到相同的结果。同一个函数无论被调用多少次，得到的结果都是一样的。
> 安全性：指不让操作对象的状态发生变化。而副作用表示使状态发生变化，所以安全性还可以说成“对操作对象的状态没有副作用”。

## 正交性

**What** :question:

正交在几何学中指两条线段如直角坐标系一般相交且成直角。让某点沿x轴平移时，x值会发生变化，但y值不变。也就是说，x值的改变不会对y值造成影响。

代码也应满足正交性。也就是说，代码之间应具有独立性和分离性。

假设有两组代码。如果修改其中一方不会对另外一方造成影响，那么这两组代码就是正交的。正交的代码在修改时不容易出现问题。

**How** :question:

我们要让模块间的耦合度最小化。也就是说，不对其他模块公开不必要的信息，与此同时，保证代码不依赖于其他模块的实现。

层次化是将代码之间的耦合度最小化的有效手段。

> [!note]
>
> 正交代码的优点：
>
> - 提高生产效率
> - 降低风险

## 可逆性

**What** :question:

可逆指发生某种变化后，可通过添加条件回到原本状态的性质。程序中的判断应时常保持可逆性。禁止使用无法还原的方案。

**How** :question:

为了能经受住变化的考验，我们的设计需要能回到之前的状态。为此，代码一定要有灵活性，不依赖于特定技术，能灵活应对变化。

> [!note]
>
> 不存在最终解决方案

## 童子军规则

**What** :question:

美国童子军有一项很简单的规则，那就是“离开自己所在的地方时，这个地方必须比来时更干净”。就算弄脏露营场地的不是自己，也必须打扫干净再离开。

这个规则同样适用于编程。在离开之前，要让代码变得比自己来时更整洁。代码最初是谁写的并不重要，重要的是我们要努力改善它。

**How** :question:

对于代码，我们要养成先改善再提交的习惯。这也有助于保持代码简洁。

> [!note]
>
> - 抑制代码腐烂。
> - 编程讲究稳中求胜
>   - 在无法直接获取价值的情况下，省去单元测试
>   - 为削减成本，强行使用与目的不符的现有系统
>   - 发现选了不合适的库却不进行处理

## 性能调优的箴言

**What** :question:

所谓性能调优，就是编写运行速度快的代码。性能调优也称为代码优化。

很多人认为加快代码的运行速度是一件好事。但实际上，过早优化代码会产生各种问题。

因此，对于代码优化，我们要遵守以下规则。

- 不要在编程之初就对代码进行优化
- 编程之初暂时不要对代码进行优化（适用于专家）

代码优化并不是我们在编程之初就应该考虑的事情。在编程时，我们要注意的是代码的正确性和可读性，编写高质量的代码，而不是想方设法让代码的运行速度变快。

**How** :question:

我们要先写高质量的代码，然后根据需要进行优化。

> [!note]
>
> 快代码的弊端：
>
> - 可读性变低
> - 质量变差
> - 复杂度增大
> - 阻碍维护
> - 与环境相冲突
> - 工作量增多

> [!note]
>
> 性能调优流程：
>
> - 证明优化的必要性
> - 测量性能，找出瓶颈
> - 优化瓶颈部分的代码
> - 测量性能，确认优化效果
> - 验证优化后的代码是否存在运行问题