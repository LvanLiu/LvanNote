# :shit: ​Bad smell

> 靠代码行数来衡量开发进度，就像是凭重量来衡量飞机制造的进度。——比尔·盖茨

## 原则

- 面向对象的封装，关键点是行为，避免滥用setter，导致暴露对象的内部细节。
- 避免宽泛的命名，命名应描述意图。

## 语句

### 滥用setter方法

记得以前的一次code review，我注意到了以下这段代码：

```java
public class OrderService {
    public PayResult pay() {
        ...
        //设置支付成功的状态
        order.setStatus(1);
        ...
    }
}
```

以上支付的主要逻辑是调起支付请求，支付成功后，记录订单的状态，设置为成功(这里暂时用1来表示，其实应该设置为枚举的)，然后再将订单持久化到数据库中。相信，很多人看到这类代码还是觉得挺不错的。但是，以上通过setStatus来设置状态，实际是将一个类的内部行为暴露出来了，这是一种破坏封装的做法。

我们再来改一下代码：

```java
public class Order {
    private int status;
    
    public void paySuccess() {
        this.status = 1;
    }
}
public class OrderService {
        public PayResult pay() {
        ...
        order.paySuccess();
        ...
    }
}
```

通过修改代码后，订单状态统一到Order类中管理，其他类不需要了解Order类中Stauts的取值，只需要调用了解Order的行为即可。

setter的出现，是对封装的破坏，它把一个类内部的实现细节暴露出来。**面向对象的封装，关键点是行为**，而使用setter大多数是做了数据的聚合，缺少了行为的设计，**再进一步，setter还意味着变化。**

>[!attention]
>:bookmark_tabs: 一个好的设计应该尽可能追求不变性。

##  命名

### 缺少精准的命名

我以前也写过比较多缺少精准命名的代码，而且还特别喜欢以下两类：

```java
public void processDepartment(List<Department> departments) {
}

public void payHandler(PayReuqest payRequest) {
}
```

processDepartment函数的主要目的是与钉钉的部门信息保持同步，payHandler主要是负责订单支付，以前看这两个函数，我觉得还是挺合适的，但是过了一段时间，回头看这两个函数，却不能单从函数名看出这个函数的意图是什么，反而必须要通过阅读代码，才能知晓。因此，以上的两个函数的命名太宽泛了。

这是一类典型的命名问题，从表面上看，名字是有含义的，但实际上，它并不能有效地反映这段代码的含义。从沟通的角度来讲，这不是一个有效的沟通，而需要耗费大量的时间和精力，才能理解它。

我们将以上函数命名修改为：

```java
public void syncDepartment(List<Department> departments) {
}

public void pay(PayReuqest payRequest) {
}
```



如果代码上出现以下这些词，则需要进一步考虑，它是否能够表达

>[!attention]
>:bookmark_tabs: 