# :shit: ​Bad smell

> 靠代码行数来衡量开发进度，就像是凭重量来衡量飞机制造的进度。——比尔·盖茨

## Salute

1. 面向对象的封装，关键点是行为，避免滥用setter，导致暴露对象的内部细节。
2. 避免宽泛的命名，命名应描述意图，而非细节。
3. 编写符合语法规则的代码。
4. 别乱用英语，类要用名词，函数要用动宾或者动词，适用符合业务场景的词汇。
5. 不要违反DRY原则。
6. 写函数时，需要分离关注点，尽量把函数写短。

------



## 细品

### 语句

#### 滥用setter方法

记得以前的一次code review，我注意到了以下这段代码：

```java
public class OrderService {
    public PayResult pay() {
        ...
        //设置支付成功的状态
        order.setStatus(1);
        ...
    }
}
```

以上支付的主要逻辑是调起支付请求，支付成功后，记录订单的状态，设置为成功(这里暂时用1来表示，其实应该设置为枚举的)，然后再将订单持久化到数据库中。相信，很多人看到这类代码还是觉得挺不错的。但是，以上通过setStatus来设置状态，实际是将一个类的内部行为暴露出来了，这是一种破坏封装的做法。

我们再来改一下代码：

```java
public class Order {
    private int status;
    
    public void paySuccess() {
        this.status = 1;
    }
}
public class OrderService {
        public PayResult pay() {
        ...
        order.paySuccess();
        ...
    }
}
```

通过修改代码后，订单状态统一到Order类中管理，其他类不需要了解Order类中Stauts的取值，只需要调用了解Order的行为即可。

setter的出现，是对封装的破坏，它把一个类内部的实现细节暴露出来。**面向对象的封装，关键点是行为**，而使用setter大多数是做了数据的聚合，缺少了行为的设计，**再进一步，setter还意味着变化。**

>[!attention]
>
>一个好的设计应该尽可能追求不变性。

#### 滥用控制语句

滥用控制语句呈现的形态：

- 嵌套的代码
- else语句
- 重复的swtich
- 循环的语句

消灭滥用控制语句的原则：

- 嵌套的代码首先要对代码进行关注点分离（可以参考以下函数模块的长函数），使用卫语句取代嵌套的条件表达式，遵循函数至多有一层缩进规则
- 不要使用else关键字，在if模块尽早return
- 使用多态或者策略模式来取代条件表达式，如消灭重复的swtich
- 遵循开闭原则

>[!attention]
>
>循坏和选择语句，可能都是坏味道

###  命名

#### 缺少精准的命名

我以前也写过比较多缺少精准命名的代码，而且还特别喜欢以下两类：

```java
public void processDepartment(List<Department> departments) {
}

public void payHandler(PayReuqest payRequest) {
}
```

processDepartment函数的主要目的是与钉钉的部门信息保持同步，payHandler主要是负责订单支付，以前看这两个函数，我觉得还是挺合适的，但是过了一段时间，回头看这两个函数，却不能单从函数名看出这个函数的意图是什么，反而必须要通过阅读代码，才能知晓。因此，以上的两个函数的命名太宽泛了。

这是一类典型的命名问题，从表面上看，名字是有含义的，但实际上，它并不能有效地反映这段代码的含义。从沟通的角度来讲，这不是一个有效的沟通，而需要耗费大量的时间和精力，才能理解它。

根据以下原则进行命名改善：

- 命名要能够描述这段代码在做的事情。
- 一个好的名字应该描述意图，而非细节。

根据以上两个原则，我们将以上函数命名修改为：

```java
public void syncDepartment(List<Department> departments) {
}

public void pay(PayReuqest payRequest) {
}
```

syncDepartment表示同步部门信息，那么该函数做的事情就是将部门信息同步到本地。pay表示支付，那么该函数主要就是负责支付功能。

>[!attention]
>
>当有这些词出现在代码里，应该要改用更精准的词去替代。
>
>宽泛的词：data、info、flag、process、handle、build、maintain、manage、modify

#### 用技术用语命名

用技术用语命名，是很多程序员的习惯，这种代码到处可见，同时，大部分人都不认为这是一个问题。上代码：

```java
List<Integer> userIdList = new LinkedList<>();
```

以上的变量之所以命名为userIdList，那是因为使用了List集合类，类比，还有xxxMap，xxxSet等。如果后面userIdList的数据类型修改为Map，然后没有修改变量，那么这个变量的命名就是毫无相关了。这类命名都是基于实现的细节来命名。

修改这类命名，我们需要遵循**面向接口编程**，因为接口是稳定的，实现是可变的。上代码：

```java
List<Integer> userIds = new LinkedList<>();
```

>[!attention]
>
>- 在一个技术类的项目中，这些技术语其实就是它的业务语言。但对于业务项目，这个说法就必须重新审视了。
>
>- 命名中出现技术用语，往往它是缺少了一个模型。

#### 乱用英语

**违反语法规则**

类型、函数名不满足语法规则，一般来说，类名是一个名词，表示一个对象，而方法名则是一个动词，或者是动宾短语，表示一个动作。

**不准确的英语词汇**

使用不准确的英语来命名，在这种情况下，最好的解决方案还是建立一个业务词汇表，千万不要臆想。

>[!attention]
>
>1. 编写符合英语语法规则的代码
>2. 通过代码审查发现问题

### 函数

#### 重复代码

出现重复代码，不外乎以下几种原因：

- 复制粘贴代码
- 结构重复的代码
- if和else代码块中的语句高度类似

消灭重复代码的原则：

- 每一处知识都必须有单一、明确、权威地表述。
- 不要被**“动词”**上的差异迷惑，结构重复，也是重复代码。

>[!attention]
>
>要时刻牢记，不要违反DRY原则，不要复制粘贴代码

#### 长函数

在一些代码检查插件上，超过80行的代码则认为是长函数。总之，**对函数长度容忍度高，是导致长函数产生的关键点。**

长函数产生的主要原因，如下：

- 以性能为由：减少调用函数进出栈的性能损耗。
- 平铺直叙：主要是把多个业务处理流程放在一个函数实现或者把不同层面的细节放到一个函数里实现。
- 一次加一点：每次都往函数里加一些代码，这种无意识的累积，虽然每个人都有正当的理由，但是最终的结果很糟糕。

消灭长函数的原则：

- 定义好函数长度的标准。
- 做好“分离关注点”。
- 坚守“让营地比你来时更干净”（童子军军规）规则。

重构手法

- 分离关注点，提取函数。

>[!attention]
>
>把函数写短，越短越好

#### 长参数列表

消除长参数：

1. 参数数量多导致的长参数
   - 变化频率相同，则封装成一个类
   - 变化频率不同：
     - 静态不变的，可以成为软件结构的一部分（如，成为类的成员变量）
     - 多个变化频率的，可以封装成几个类
2. 标记参数导致的长函数
   - 根据标记参数，将函数拆分成多个函数

重构手法：

- 将参数列表封装成对象
- 移除标记参数

> [!attention]
>
> 减少参数列表，越小越好

### 类

#### 大类

大类的产生的原因：

- 职责不单一
- 字段未分组

消灭大类的原则：

- 遵循单一职责原则，将大类拆分为小类，本质上是在做设计工作
- 将可变的同一种性质的字段进行分组。

>[!attention]
>
>- 极致的追求：每个类不超过2个字段
>- 把类写好，越小越好