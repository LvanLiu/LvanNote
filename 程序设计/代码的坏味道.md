# :shit: ​Bad smell

> 靠代码行数来衡量开发进度，就像是凭重量来衡量飞机制造的进度。——比尔·盖茨

## Salute

- 面向对象的封装，关键点是行为，避免滥用setter，导致暴露对象的内部细节。
- 避免宽泛的命名，命名应描述意图，而非细节。

------



## 细品

### 语句

#### 滥用setter方法

记得以前的一次code review，我注意到了以下这段代码：

```java
public class OrderService {
    public PayResult pay() {
        ...
        //设置支付成功的状态
        order.setStatus(1);
        ...
    }
}
```

以上支付的主要逻辑是调起支付请求，支付成功后，记录订单的状态，设置为成功(这里暂时用1来表示，其实应该设置为枚举的)，然后再将订单持久化到数据库中。相信，很多人看到这类代码还是觉得挺不错的。但是，以上通过setStatus来设置状态，实际是将一个类的内部行为暴露出来了，这是一种破坏封装的做法。

我们再来改一下代码：

```java
public class Order {
    private int status;
    
    public void paySuccess() {
        this.status = 1;
    }
}
public class OrderService {
        public PayResult pay() {
        ...
        order.paySuccess();
        ...
    }
}
```

通过修改代码后，订单状态统一到Order类中管理，其他类不需要了解Order类中Stauts的取值，只需要调用了解Order的行为即可。

setter的出现，是对封装的破坏，它把一个类内部的实现细节暴露出来。**面向对象的封装，关键点是行为**，而使用setter大多数是做了数据的聚合，缺少了行为的设计，**再进一步，setter还意味着变化。**

>[!attention]
>
>一个好的设计应该尽可能追求不变性。

###  命名

#### 缺少精准的命名

我以前也写过比较多缺少精准命名的代码，而且还特别喜欢以下两类：

```java
public void processDepartment(List<Department> departments) {
}

public void payHandler(PayReuqest payRequest) {
}
```

processDepartment函数的主要目的是与钉钉的部门信息保持同步，payHandler主要是负责订单支付，以前看这两个函数，我觉得还是挺合适的，但是过了一段时间，回头看这两个函数，却不能单从函数名看出这个函数的意图是什么，反而必须要通过阅读代码，才能知晓。因此，以上的两个函数的命名太宽泛了。

这是一类典型的命名问题，从表面上看，名字是有含义的，但实际上，它并不能有效地反映这段代码的含义。从沟通的角度来讲，这不是一个有效的沟通，而需要耗费大量的时间和精力，才能理解它。

根据以下原则进行命名改善：

- 命名要能够描述这段代码在做的事情。
- 一个好的名字应该描述意图，而非细节。

根据以上两个原则，我们将以上函数命名修改为：

```java
public void syncDepartment(List<Department> departments) {
}

public void pay(PayReuqest payRequest) {
}
```

syncDepartment表示同步部门信息，那么该函数做的事情就是将部门信息同步到本地。pay表示支付，那么该函数主要就是负责支付功能。

>[!attention]
>
>当有这些词出现在代码里，应该要改用更精准的词去替代。
>
>宽泛的词：data、info、flag、process、handle、build、maintain、manage、modify

#### 用技术用语命名

用技术用语命名，是很多程序员的习惯，这种代码到处可见，同时，大部分人都不认为这是一个问题。上代码：

```java
List<Integer> userIdList = new LinkedList<>();
```

以上的变量之所以命名为userIdList，那是因为使用了List集合类，类比，还有xxxMap，xxxSet等。如果后面userIdList的数据类型修改为Map，然后没有修改变量，那么这个变量的命名就是毫无相关了。这类命名都是基于实现的细节来命名。

修改这类命名，我们需要遵循**面向接口编程**，因为接口是稳定的，实现是可变的。上代码：

```java
List<Integer> userIds = new LinkedList<>();
```

>[!attention]
>
>- 在一个技术类的项目中，这些技术语其实就是它的业务语言。但对于业务项目，这个说法就必须重新审视了。
>
>- 命名中出现技术用语，往往它是缺少了一个模型。