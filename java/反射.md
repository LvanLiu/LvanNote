# 一文搞懂Java反射

> 学习发射是非常重要的，平时开发的常用的注解以及Spring Aop都需要依赖反射来完成，因此系统地学习一次反射，也有利于阅读开源代码。

## 何为反射

反射库（java.lang.reflect）提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序。

能够分析类能力的程序称为反射（reflective），反射机制的功能极其强大，可以在运行时访问Java对象的属性、方法、构造函数等，其中**动态代理**是反射最经典的应用。

------



## 反射真的这么好吗

从Spring的IOC以及AOP层面来看，其对象的依赖注入需要依赖反射来构造对象，AOP则需要依赖动态代理来对方法进行增强，结合此场景来分析，反射就具备以下优点：

- 增加程序的灵活性，避免代码侵入
- 代码简洁，符合单一原则

但反射也是有缺点的：

- 性能开销

- 内部曝光：可以通过[AccessibleObject类的作用](#AccessibleObject)知道原因

  ------

  

## 反射核心API源码分析

> 从源码的角度学习反射的API，只有熟悉了解反射的API，才能够应用好反射。
>
> 以下遵循从顶层接口到实现类的结构进行分析，从上到下阅读，就可以了解反射相关的API以及一部分的实现原理

### AnnotatedElement

此接口定义了注解信息获取的一些接口，如下：

```java
//判断该类上是否存在注解类，通过此源码可以看出它默认实现是通过getAnnotation来实现的
default boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
    return getAnnotation(annotationClass) != null;
}

//根据注解类型，获取元素上指定的注解信息
<T extends Annotation> T getAnnotation(Class<T> annotationClass);

//获取元素上所有的注解信息，它会获取父类上被@Inherited标记的注解
Annotation[] getAnnotations();

//获取当前元素所有注解信息，若此元素存在继承关系，
Annotation[] getDeclaredAnnotations();

//根据指定的注解类型，获取声明在当前元素上的注解信息，默认是通过遍历getDeclaredAnnotations()获取的注解数组来实现。
default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) {
    Objects.requireNonNull(annotationClass);
    // Loop over all directly-present annotations looking for a matching one
    for (Annotation annotation : getDeclaredAnnotations()) {
        if (annotationClass.equals(annotation.annotationType())) {
            // More robust to do a dynamic cast at runtime instead
            // of compile-time only.
            return annotationClass.cast(annotation);
        }
    }
    return null;
}
```
> [!tip]
> 关于@Inherited元注解的作用可以参考：[关于Java中使用@Inherited的说明](https://blog.csdn.net/snow_crazy/article/details/39381695)

通过以下的Uml图，可以看出Field、Class、Constructor、Method、Package都实现了此接口。

<img src="../img/AnnotatedElement.jpg">

------



### <span id = "AccessibleObject">AccessibleObject</span>

通过AnnotatedElement的UML图，可以看出AccessibleObject是AnnotatedElement的一个实现，并且AccessibleObject也作为Field、Method 和 Constructor 对象的基类。

它的主要功能是可以**抑制或取消**默认Java语言访问控制检查的能力，也就是可以通过AccessibleObject类提供的功能来修改类的访问控制（如：反射时可以通过setAccessible(true)来修改其权限，使得其他类可以访问该类的成员变量）。

基于AccessibleObject的强大功能，也让反射拥有了**内部曝光**的缺点了。

以下通过阅读源码，来了解此类的主要功能。

```java
//它实现了AnnotatedElement接口的方法，但是都是以抛异常的方式进行实现，也就是说此类仅仅是负责访问类权限授权的工作，获取注解等相关信息留给子类去实现
//其实也就是单一原则设计理念的体现
public Annotation[] getDeclaredAnnotations()  {
    throw new AssertionError("All subclasses should override this method");
}

//简单来说，就是将成员变量override设置为true, 在设置之前会进行权限校验，不允许修改constructor(构造器)的访问权限。
private static void setAccessible0(AccessibleObject obj, boolean flag)
    throws SecurityException {
    if (obj instanceof Constructor && flag == true) {
        Constructor<?> c = (Constructor<?>)obj;
        if (c.getDeclaringClass() == Class.class) {
            throw new SecurityException("Cannot make a java.lang.Class" +
                                        " constructor accessible");
        }
    }
    obj.override = flag;
}

//设置实例是否可以访问，如果设置为true，可以抑制修饰符，直接进行访问
public void setAccessible(boolean flag) throws SecurityException {
    SecurityManager sm = System.getSecurityManager();
    if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
    
    setAccessible0(this, flag);
}
```

------



### Type（泛型系）

Type 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。

Type的扩展子接口有以下几种：

<img src="../img/Type.png">

其中顶层接口Type中仅定义了一个方法：

```java
//简单的理解就是Type toString()方法
default String getTypeName() {
    return toString();
}
```

------



#### ParameterizedType

ParameterizedType用于表示泛型/参数化类型，它定义的接口如下：

```java
//获取实例类型参数的Type对象数组，也就是获取泛型<>里的类型参数的类型。
//如List<String,String>, 通过此函数获取的是java.lang.String数组
Type[] getActualTypeArguments();

//获取声明此类型的类或接口，如List<String>，通过此函数获取的是java.util.List
Type getRawType();

//通过例子去理解此函数，如通过Map.Entry<T,U>来调用此函数，那么返回的是Map接口，当如果像List<T>这些接口，它属于顶层接口，那么此函数返回的是null
Type getOwnerType();
```

------



#### TypeVariable

TypeVariable用于表示参数化类型中的T、E、K等类型变量，表示泛指任何类，如Map<K,V>接口中的K,V的类型就是TypeVariable。它定义的接口如下：

```java
//返回此类型变量的上界Type对象数组，如<K extends Comparable & Serializable, V>，那么此函数返回的是[java.lang.Comparable,java.io.Serializable]
Type[] getBounds();

//获得声明（定义）这个泛型变量的类型
D getGenericDeclaration();
```

------



#### GenericArrayType

GenericArrayType表示的泛型数组，其组件类型(数组内的元素类型)为ParameterizedType或者TypeVariable。它只定义了一个函数，如下：

```java
//返回表示此数组的组件类型的 Type 对象
Type getGenericComponentType();
```

------



#### WildcardType

WildcardType表示的泛型的通配符表达式，如[?]、[? super T]、[? extends T]。

虽然WildcardType是Type的一个子接口，但并不是Java类型中的一种，它定义的接口如下：

```java
//返回表示此类型变量上边界的 Type 对象的数组。注意，如果不存在显式声明的上边界，则上边界为 Object
Type[] getUpperBounds();

//返回表示此类型变量下边界的 Type 对象的数组。注意，如果不存在显式声明的下边界，则下边界为类型 null。在此情况下，将返回长度为零的数组
Type[] getLowerBounds();
```

------

> [!tip]
> 经过以上几个Type的子接口分析，可以Type接口可以用于描述泛型。

### AnnotatedType（注解系）

AnnotatedType表示当前程序中可能被注解的类型，它的作用于Type接口相似，只是AnnotatedType是用于获取泛型上声明的注解信息，它的扩展接口有以下几种：

<img src="../img/AnnotatedType.png">

通过扩展子接口的命名，可以看出其意义与以上的Type子接口差不多，只不过AnnotatedType的子接口是面向于注解的。

##### AnnotatedParameterizedType

AnnotatedParameterizedType表示那些可能带注解的ParameterizedType类型的数据，如Map<String, String>定义的参数类型String, 它是一个ParameterizedType类型，也是AnnotatedParameterizedType参数类型，只是Map<String, String>没有使用注解而已，如果使用上注解，如Map<@Anno String, @Anno String>的话，那么就可以通过AnnotatedParameterizedType来获取参数类型上的注解信息了。

它只定义的一个接口，如下：

```java
AnnotatedType[] getAnnotatedActualTypeArguments();
```