# TDD入门

## 使用TDD的好处

测试驱动开发可简化重构工作、帮助创建更好的设计、降级耦合复杂度以及获取极高的代码覆盖率。

## 理解TDD

TDD是一种简单的流程，要求你先编写测试、再编写实现代码，这与”编写代码后测试“的传统是相反的。

## 红灯-绿灯-重构

测试驱动开发是一个过程，依赖于不断重复极短的开发周期。它基于极限编程（XP）的测试优先理念，倡导采用可高度信赖的简单设计。驱动这个流程前行的开发周期称为“**红灯-绿灯-重构**”。

这种流程本身很简单，由以下几个反复进行的步骤组成：

1. 编写一个测试；
2. 运行所有测试；
3. 编写实现代码；
4. 运行所有测试；
5. 重构；
6. 运行所有测试

> [!ATTENTION]
> 编写测试时，应处于红灯状态。完成测试要求的实现后，所有测试都应通过，此时将处于绿灯状态。

如果最后一个测试未通过，就说明实现不通过，必须修正；要么这个测试不正确，要么实现的代码不符合我们制定的规范。如果其他测试未通过，就说明我们破坏了某种功能，必须撤销所有修改。

> [!ATTENTION]
> 不要试图让最后一个测试的实现完美无缺，而应编写足以让这个测试通过的代码。

你可以以任何喜欢的方式编写代码，但要快。一旦进入绿灯状态，我们就知道存在一个由测试构成的安全网，可接着重构代码：改进和优化代码，但不引入新功能。重构结束后，所有测试应当在任何情况下都能通过。

如果重构期间有测试未通过，就说明重构破坏了既有的功能，应像以前一样撤销所有的修改。在重构阶段，我们不修改任何的功能，也不引入新的测试，而只改进代码，并不断运行所有测试，确保没有破坏任何功能。与此同时，我们证明了代码是正确的，并降低了未来的维护成本。

重构结束后，再重复整个过程。这是一个无限循环，每次循环都是一个极短的周期。

**速度是关键**

测试和实现的切换时间应以分钟甚至秒计。

**TDD并非测试方法**

测试驱动开发的主要目的是提供可测试的代码设计，测试只是一项很有用的副产品。

## 测试

### 黑盒测试

黑盒测试（也叫功能测试）将受测软件视为一个黑盒子、无需知道其内部构造。这种测试是通过软件界面进行的，旨在确认它们像预期的那样工作。只要界面的功能未变，测试就应通过——即便内部构造发生了变化。

优点：
- 可高效测试大块代码段；
- 无需访问和理解代码，也不要求测试人员知道如何编写代码；
- 将用户角度和开发人员角度分离；

缺点：
- 覆盖率有限，因为只执行部分测试场景；
- 测试效率低下，因为测试人员对软件内部构造一无所知；
- 测试缺乏针对性，因为测试人员对应用程序的了解有限；

> [!NOTE]
> 自动化黑盒测试依赖于某种形式的自动化，如**行为驱动开发（BDD）**

### 白盒测试

白盒测试（也叫透明盒测试、玻璃盒测试和结构测试）查看受测软件的内部，并将由此获得的知识用于测试的过程。

优点：
- 可高效找出错误和问题；
- 知道受测软件的内部构造有助于进行详细的测试；
- 能够发现隐藏的错误；
- 可帮助程序员反省；
- 有助于优化代码；
- 由于知道软件的内部构造，因此最大限度地提供测试覆盖率；

缺点：
- 可能无法发现未实现或缺失的功能；
- 需要对受测软件的内部构造有大致的认识；
- 需要访问代码；
- 测试通常与产品代码的实现细节紧密耦合，导致重构代码后原本应该通过的测试未能通过；

白盒测试几乎都是自动化测试，且在大多数情况下都是单元测试。

> [!ATTENTION]
> 在实现前执行的白盒测试是以TDD方式编写的。

## 模拟

要让测试能够快速运行并不断提供反馈，必须以合适的方式组织代码，以便能够轻松使用模拟对象和存根替换方法、函数和类。这种替换实际代码的方式通常称为“测试替身”。

> [!NOTE]
> 无论是否使用模拟对象，都应以合适的方式编写代码，以便能够轻松用一个依赖对象替换另一个依赖对象。

## 可执行文档

TDD（以及更多结构良好测试）另一个很有用的方面是文档。测试就是可执行的文档，而TDD是创建和维护这种文档的最常用方式。

## 无需调试

在编写代码前编写测试且代码覆盖率很高的情况下，我们完全可以相信应用程序将像预期的那样工作，这不意味着没有bug，bug是肯定存在的，但是能够通过单元测试很快找出bug的所在。

> [!NOTE]
> 代码覆盖率很高的情况下，与逐行调试直到找到罪魁祸首相比，通过测试找出bug的原因要快得多。