# 单元测试的艺术-核心技术

## 核心技术

### 使用存根破除依赖

**外部依赖项**

定义：一个外部依赖项是系统中的一个对象，被测试代码与这个对象发生交互，但你不能控制这个对象。（常见的外部依赖项包括文件系统、线程、内存以及时间等）。

**存根**

定义：一个存根是对系统中存在的一个依赖项（或者协作者）的可控制的替代物。通过使用存根，你在测试代码时无需直接处理这个依赖项。

在测试代码中，我们可以使用**存根**来回避外部依赖项的问题。

> [!tip]
> 模拟对象和存根很类似，但是你会模拟对象进行断言，而不会对存根进行断言。

使用**存根**的参考方案：

- 抽取接口使底层实现可替换
- 依赖注入：在被测试单元中注入一个伪实现
- 构造函数注入：利用构造函数注入一个伪对象
- 利用伪对象来模拟异常
- 用属性**get**或**set**注入伪对象
- 在方法被调用前注入伪对象

以上的方案会涉及到新增接口，或者新增多一些基类，那么我们可以利用抽取和重写来生成假结果，以此避免新增接口或基类的问题。

> [!ATTENTION]
> 以上方案设计不当，就会打破一些重要的面向对象原则，特别是封装原则的概念，因此关注代码的可测试性和设计也是比较重要的。

## 使用模拟对象进行交互测试

当我们的工作单元需要调用到第三方对象，那我们如何知道调用对象与被调用对象（第三方对象）发生了正确的交互呢？ 使用模拟对象可以解决此问题。

### 定义交互测试

**概念**

交互测试是对一个对象如何向其他对象发送消息（调用方法）的测试。如果一个特定的工作单元的最终结果是调用另一个对象，你就需要进行交互测试。
交互测试也被称为行为驱动测试，行为驱动测试是值测试一个对象采取的特定行为（例如向另外一个对象发送一个消息）。

> [!ATTENTION]
> 请总是把交互测试作为最后的选择，这一点非常重要。你应该优先考虑使用**基于值**或**基于状态**的测试，因为交互测试会让很多事情变得更加复杂。

**忆当年**

其实交互测试，我在以前做支付的时候，也被使用过，当时的支付项目需要对接各个银联的支付接口，但由于银联无法提供测试环境，因此前辈开发了一个称之为“挡板”的应用程序，此“挡板”作为一个模拟的对象被调用，模拟银联返回的报文，从而进行测试，当时的测试还是集成测试。
但是这种只能简单的测试几种情况，因为我们无法完全模拟银联的应用程序（也不可能完全可以模拟），因此这种交互测试仍然是存在缺陷的，因此有时候基于状态的测试也不失为一个好的选择。

**回到正文**

交互测试，需要定义到一个模拟对象。模拟对象是系统中的伪对象，它可以验证被测试对象是否按预期的方式调用了这个伪对象，因此导致单元测试通过或失败。**通常每个测试只有一个模拟你对象**。

**模拟对象、存根、伪对象它们不都是一个样吗？**

伪对象是通用的术语，可以描述一个存根或者模拟对象（手工或非手工编写），因为存根和模拟对象看上去都很像真实对象。一个伪对象究竟是存根还是模拟对象取决于它在当前测试中的使用方式：如果这个伪对象用来检验一个交互（对其进行断言），那它就是模拟对象，否则就是存根。

存根与模拟对象的区别看起来很小，但又很重要，它们之间的根本区别是**存根不会导致测试失败，而模拟对象会**，它们之间有以下特点，可以结合这些特点进行区别：

- 存根：存根永远不会导致测试失败，测试总是对被测试类进行断言
- 模拟对象：测试会使用模拟对象验证测试是否失败，测试是对模拟对象进行断言

**每个测试一个模拟对象**

原则: 如果一个测试只测试一个对象(作者推荐的测试编写方法)，测试中应该最多只有一个模拟对象。所有其他对象都是存根，如果一个测试有多个模拟对象，这说明你在测试多件事情，会导致测试过于复杂或脆弱。

遵从以上原则，在碰到更加复杂的测试时，可以先确定模拟对象，其他伪对象都作为存根，不对这些存根进行断言。如果对这些存根进行断言，这就是过度指定的迹象。

> [!TIP]
> 过度指定: 过多地指定测试中应该发生的事情的行为，而这些事情实际上对测试无关紧要。例如，代码调用了存根。

> [!NOTE]
> 手工模拟对象和存根有何问题？
> - 编写模拟对象和存根需要花费时间
> - 如果类和接口有许多方法、属性或事件，就很难为它编写存根和依赖对象
> - 要保存模拟对象多次调用的状态，你需要在手工伪实现里写许多标准代码
> - 如果要验证调用者向一个方法调用传递的所有参数都是正确的，需要多个断言，非常笨拙
> - 难以在其他测试中重用模拟对象和存根代码.基本代码还能用，但是一旦接口有超过两三个方法需要实现,代码维护就会变得异常麻烦
> - 一个伪对象可以既是模拟对象又可以是存根吗?这种情况很少，一个项目里也许能有一两个

## 小结

存根或模拟对象主要都是用于解决一个系统依赖外部对象导致无法测试的一个问题，手工编写存根和模拟对象会造成比较多的问题，不过，现在也有隔离框架可以自动生成存根和模拟对象，它比手工编写的更加强大。
