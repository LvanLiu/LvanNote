# 编写优秀的单元测试

> [!ATTENTION]
> 无论如何组织测试、无论有多少测试、如果你不能信任、维护以及阅读它们，这些测试几乎没有价值。

*优秀的测试的特性：**

- 可靠性：测试结果可靠，开发人员对此有信心
- 可维护性：无法维护的单元测试就是恶梦
- 可读性：单元测试失去可读性，就失去了可靠性以及可维护性

## 单元测试的原则和技术

### 决定何时删除或修改测试

> [!NOTE]
> 单元测试是被测试代码的保护伞，如果单元测试通过，你通常不应该删除或修改这些测试。

导致单元测试被删除或者被修改，有可能是以下原因造成的。

**产品缺陷**

产品缺陷：如果你修改了产品的代码，导致已有的一个测试失败，这就出现了一个产品缺陷。 解决方案：修复产品的缺陷，并通过单元测试（一般不需要修改单元测试，因为单元测试是完好的）。

**测试缺陷**

测试缺陷：测试代码中存在缺陷，但是一般开发人员不会直接定位到或者认为测试代码存在缺陷，需要经过一定的过程，才能发现这类问题。 解决方案：修改测试代码中的缺陷，并确保测试应该失败时失败，应该成功时成功。

**语义或者Api变更**

语义变更：被测试的产品代码产生变更导致测试失败，可能是因为测试对象的功能虽然没有改变，但是使用方式产生了变更。 解决方案：修改测试代码，以符合语义。

**冲突或者无效的测试**

冲突/无效的测试：如果产品代码引入一个新功能，和一个测试有直接冲突，那这个就是冲突测试。这种情况说明测试是没有问题的，但是发现了冲突的产品需求。
解决方案：首先应该确认这些测试是冲突的，一旦确认，你需要决定保留哪个需求。然后，你应该删除无效的需求和测试

> [!NOTE]
> 有时候，冲突的测试可以发现客户需求中的问题，客户可能需要决定各个需求是否有效

**重命名或者重构测试**

重命名/重构测试：不可读的测试代码带来的麻烦比解决的问题还要多，它会影响代码的可读性，妨碍你理解测试和发现问题的进度。 解决方案：修改测试代码，但是不改变测试代码的基本功能。

**删除重复的测试**

重复测试：

## 编写可维护的测试

**测试私有或保护方法**

> [!NOTE]
> 将方法设计到私有方法或者受保护的方法，也是有合适的理由的，我们一般设计函数的时候，都会尽可能地限定最小的权限，一方面隐藏实现细节，而另一方面主要是因为安全问题。

如果测试一个私有的方法，你测试的只是系统内部的一个契约，这个契约有可能会变化。内部契约是动态的，在系统重构时可能会修改。如果这些内部契约发生了变化，你的测试可能会失败，因为一些内部的实现发生了变化，虽然系统整体的功能不变。

私有或者受保护的方法是不会无缘无故存在的，可能被更大的测试单元使用，它是被包裹着的，甚至这个私有方法被很多多公开的方法调用，那么单纯地测试其中某个公开方法，即使测试通过，也不能说明此私有方法或受保护的方法是正常的。

> [!ATTENTION]
> 如果一个私有方法值得进行测试，那么它应该称为公开的，静态的方法。
> 但这并不意味着基础代码中就不应该有私有方法，利用TDD，我们通常会对公共方法编写测试，这些公共方法稍后会重构为调用的私小方法，在此过程中，对公共方法的测试始终能通过。

避免测试私有和保护方法，可以参考以下的做法：

- 使方法成为公开方法：使用公开方法并一定是件坏事，最初来看，这种做法是违背了面向对象的原则的，但是如果你想要测试这个方法，可能就说明这个方法对其调用者有某种已知的行为或契约。把方法设置为公开的，这个契约就成为正式的了。
但是，如果设置为私有的，那么后面的开发者有可能修改其契约，他还会担心使用这个方法的未知代码，设置为公共的，开发者就不用担心这个方法的未知性了，因为这个方法只是调用公开契约的一组东西的一部分而已。
- 将方法抽到新类：如果一个方法包含很多独立的逻辑，或者它使用的类状态只和这个方法有关，把这个方法抽取到一个具有特定功能的新类也会更好。
- 是方法成为静态方法：如果一个方法不使用所在类的任何变量，你也许可以重构这个方法，使它成为静态方法，这样更容易测试。

注意：现在存在一些开源的测试工具包，允许通过反射来修改方法的访问权限，以此达到测试私有方法的目的，这些工具需要特别考虑，因为它们也有可能生成有问题的代码。

**去除重复代码**

测试代码同样使用**DRY**原则。

**以可维护的方式去使用setup方法**

> [!ATTENTION]
> SetUp()方法使用起来很容易，实际上，有些过于容易了——以至于开发者往往会把它用于不当的用途，导致测试性和可维护性下降。

SetUp方法有以下局限性：

- setup方法只用于需要进行初始化工作时
- setup方法并不总是去除重复代码的最佳方法
- setup方法没有参数和返回值
- setup方法不能用作有返回值的工厂方法
- setup方法应该只包含适用于当前测试类中的所有测试的代码，否则这个方法会更难以阅读和理解。

请不要进行以下操作；
- 在setup方法中初始化只在某些测试中使用的对象
- setup方法代码冗长难懂
- 在setup方法中准备模拟对象和伪对象

> [!ATTENTION]
> 请停止使用setup方法吧！！！

**实施测试隔离**

概念：一个测试应该总是在它自己的小世界中运行，与其他进行类似或不同的工作测试环境，甚至不知道其他测试的存在。

单元测试的坏味道：
- 强制的测试顺序：测试需要以某种特定顺序执行，或者需要来自其他测试结果的信息。
- 隐藏的测试调用：测试调用其他测试
- 外部共享状态损坏：集成测试共享资源，却没有回滚资源

**避免对不同关注点多次断言**

一个单元测试对多个关注点进行断言，这个时候测试若出现异常，那么对于后面的断言则不会运行，这个时候你就无法知晓后面的测试结果。

可以采用以下方法来避免：
- 给每个断言创建一个单元测试
- 使用参数化测试
- 把断言放在一个try catch语句中（这种方法不太优雅）

**对象比较**

在一个单元测试中，可以使用断言一个对象的多个值，这样是可行的，同一个单元测试断言一个对象的多个值，要么测试全部通过，要么测试就是失败的，它们是一致的。

但这种情况，我们也可以准备一个预期的对象与待比较对象进行比较，若相等，则测试通过，若不相等，则测试失败，这样就可以将多个断言优化成一个了。

> [!ATTENTION]
> 对象比较，需要重新equals（）方法

**避免过度指定**

过度指定的测试对一个具体的被测试单元如何实现其内部行为进行了假设，而不是只检查其最终行为的正确性。

过度指定有如下几种情况：
- 测试对一个被测试对象的纯内部状态进行了指定
- 测试使用多个模拟对象
- 测试在需要存根时使用模拟对象
- 测试在不必要的情况下指定顺序或使用了精确匹配

**编写可读的测试**

> [!ATTENTION]
> 不可读的测试没有意义！！！

**单元测试命名**

标准规范的命名非常重要，提供了合理的规则和模板，列出应该包含的测试信息，测试名字包括三部分：
- 被测试方法名：非常关键，指明了被测试逻辑的位置。
- 测试场景：说明了测试的条件
- 预期行为：基于当前场景，方法应该产生的行为结果或者返回值，或者行为方式。

> [!NOTE]
> 如果测试名缺少了以上单元测试命名的任何一部分，测试的读者就会疑惑测试究竟在做什么，需要阅读测试代码。

**变量命名**
 
如何给单元测试的变量命名，和产品代码中的变量命名规范同等重要，甚至更为重要。除了主要的测试功能，测试还为API提供了某种形式的文档。通过合理命名变量，你可以确保阅读测试的人可以尽快地理解你要验证什么。

**有意义的断言**

> [!ATTENTION]
> 请尽量不要编写你自己的定制断言信息，拜托了！！！

但万不得已，编写有意义的断言，请记住以下要点：
- 不要重复测试框架的控制台输出信息
- 不要重复测试名中包含的信息
- 如果没什么有用信息，就什么也不说
- 提供关于什么应该发生和什么没有发生的信息，如果可能的话，提供应该发生的时间

**setup/teardown**

避免单元测试中滥用setUp/teardown方法。

**小结**

单元测试是随着测试系统一同成长和变化的，编写单元测试一定要考虑是否可读、是否可维护以及是否可靠，能做到这三点，已经是很优秀的单元测试了。
